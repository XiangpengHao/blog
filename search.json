[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Database/storage systems",
    "section": "",
    "text": "What happens when you type a SQL in the database\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/sql-to-results/index.html",
    "href": "posts/sql-to-results/index.html",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.\nAs complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) Apache DataFusion project is a good example of building a database using well-defined industry standards like Apache Arrow, and Apache Parquet. Without home-grown solutions for storage and in-memory representation, DataFusion is comparable or even better than alternatives like DuckDB.\nThis document aims to explain how modern query engines (i.e., OLAP) work, step by step, from SQL to results:\n\n\n\n\n\nflowchart LR\n   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] \n   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5\n   id5[Physical plan] --&gt; |Execution| id7[Output]\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis working-in-progress blog post explains how a database query engine works. This is a blog post I hoped I knew when I was younger.\nI aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the OSTEP book (might be too ambitious, though)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#preface",
    "href": "posts/sql-to-results/index.html#preface",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.\nAs complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) Apache DataFusion project is a good example of building a database using well-defined industry standards like Apache Arrow, and Apache Parquet. Without home-grown solutions for storage and in-memory representation, DataFusion is comparable or even better than alternatives like DuckDB.\nThis document aims to explain how modern query engines (i.e., OLAP) work, step by step, from SQL to results:\n\n\n\n\n\nflowchart LR\n   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] \n   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5\n   id5[Physical plan] --&gt; |Execution| id7[Output]\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis working-in-progress blog post explains how a database query engine works. This is a blog post I hoped I knew when I was younger.\nI aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the OSTEP book (might be too ambitious, though)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "href": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 1: End-To-End View",
    "text": "Section 1: End-To-End View\n\nInput\n\nTable definition\nWe have the following two tables (adapted from TPC-H spec): lineitem and orders. The lineitem defines the the shipment dates, while the order defines order details.\n\n\n\n\n\nerDiagram\n  lineitem {\n      int l_orderkey\n      int l_linenumber\n      date l_shipdate\n      date l_commitdate\n      date l_receiptdate\n      string l_shipmode\n      string l_comment\n  }\n  orders {\n      int o_orderkey\n      date o_orderdate\n      string o_orderpriority\n      string o_clerk\n      string o_comment\n  }\n\n\n\n\n\n\n\n\nSQL query\nLet’s say we have this simple query (adapted from TPC-H query 5), which finds the l_orderkey, l_shipdate, and o_orderdate of orders that were placed in 1994.\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\n\n\n\nOutput\nThe query is pretty simple; it joins two tables on the order key and then filters the results based on the order date. If everything goes well, we should get results similar to this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-2-parsing",
    "href": "posts/sql-to-results/index.html#section-2-parsing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 2: Parsing",
    "text": "Section 2: Parsing\nI skipped it for now as it is mostly orthogonal to the data system pipelines.\n\nInput\nThe SQL query text.\n\n\nOutput\nStructured statement from the SQL (significantly simplified for brevity):\nfrom: [\n  TableWithJoins {\n    relation: Table {\n      name: ObjectName([\n        Ident {\n          value: \"orders\",\n          quote_style: None,\n        },\n      ]),\n    },\n    joins: [\n      Join {\n        relation: Table {\n          name: ObjectName([\n            Ident {\n              value: \"lineitem\",\n              quote_style: None,\n            },\n          ]),\n        },\n        join_operator: Inner(\n          On(\n            BinaryOp {\n              left: Identifier(\n                Ident {\n                  value: \"l_orderkey\",\n                  quote_style: None,\n                },\n              ),\n              op: Eq,\n              right: Identifier(\n                Ident {\n                  value: \"o_orderkey\",\n                  quote_style: None,\n                },\n              ),\n            },\n          ),\n        ),\n      },\n    ],\n  },\n],\nselection: Some(\n  BinaryOp {\n    left: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: GtEq,\n      right: TypedString {\n        data_type: Date,\n        value: \"1994-01-01\",\n      },\n    },\n    op: And,\n    right: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: Lt,\n      right: TypedString {\n        data_type: Date,\n        value: \"1995-01-01\",\n      },\n    },\n  },\n),"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-3-query-planning",
    "href": "posts/sql-to-results/index.html#section-3-query-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 3: Query Planning",
    "text": "Section 3: Query Planning\n\nInput\nThe query statement from the last step.\n\n\nOutput\nThe logical query plan is something like this:\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Filter: orders.o_orderdate &gt;= CAST(Utf8(\"1994-01-01\") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(\"1995-01-01\") AS Date32)\n    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n      TableScan: orders\n      TableScan: lineitem\nPlot it as a tree.\n\n\n\n\n\n\n\n\n\n\n2\n\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n\n\n\n3\n\nFilter: orders.o_orderdate &gt;= CAST(Utf8(_1994-01-01_) AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(_1995-01-01_) AS Date32)\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nInner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n\n\n\n3-&gt;4\n\n\n\n\n\n5\n\nTableScan: orders\n\n\n\n4-&gt;5\n\n\n\n\n\n6\n\nTableScan: lineitem\n\n\n\n4-&gt;6\n\n\n\n\n\n\n\n\n\n\nLogical vs physical.\nTodo: describe why we must distinguish between physical and logical plans."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "href": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 4: Query Optimizing",
    "text": "Section 4: Query Optimizing\n\nInput\nThe (unoptimized) logical plan from the last step.\n\n\nOutput\nAn optimized logical plan.\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Inner Join: orders.o_orderkey = lineitem.l_orderkey\n    Filter: orders.o_orderdate &gt;= Date32(\"8766\") AND orders.o_orderdate &lt; Date32(\"9131\")\n      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(\"8766\"), orders.o_orderdate &lt; Date32(\"9131\")]\n    TableScan: lineitem projection=[l_orderkey, l_shipdate]\n\n\n\n\n\n\n\n\n\n\n2\n\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n\n\n\n3\n\nInner Join: orders.o_orderkey = lineitem.l_orderkey\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nFilter: orders.o_orderdate &gt;= Date32(_8766_) AND orders.o_orderdate &lt; Date32(_9131_)\n\n\n\n3-&gt;4\n\n\n\n\n\n6\n\nTableScan: lineitem projection=[l_orderkey, l_shipdate]\n\n\n\n3-&gt;6\n\n\n\n\n\n5\n\nTableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(_8766_), orders.o_orderdate &lt; Date32(_9131_)]\n\n\n\n4-&gt;5\n\n\n\n\n\n\n\n\n\n\nNote the difference between an unoptimized and an optimized plan! The Filter has been pushed down to lower-level nodes. Part of the projection has been embedded in the TableScan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-5-physical-planning",
    "href": "posts/sql-to-results/index.html#section-5-physical-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 5: Physical Planning",
    "text": "Section 5: Physical Planning\n\nInput\nA logical plan.\n\n\nOutput\nA physical plan. Unlike logical plans, physical plans are more concrete about what to do; here’s an example:\nPhysical plan:\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n  CoalesceBatchesExec: target_batch_size=8192\n    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n          CoalesceBatchesExec: target_batch_size=8192\n            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\nWe can also plot a physical plan to a tree graph:\n\n\n\n\n\n\n\n\n\n\n1\n\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n\n\n\n2\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n\nHashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n3-&gt;4\n\n\n\n\n\n10\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n3-&gt;10\n\n\n\n\n\n5\n\nRepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n\n\n\n4-&gt;5\n\n\n\n\n\n6\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n5-&gt;6\n\n\n\n\n\n7\n\nFilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n\n\n\n6-&gt;7\n\n\n\n\n\n8\n\nRepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n\n\n\n7-&gt;8\n\n\n\n\n\n9\n\nCsvExec: file_groups={1 group: [[orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n\n\n\n8-&gt;9\n\n\n\n\n\n11\n\nRepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n\n\n\n10-&gt;11\n\n\n\n\n\n12\n\nRepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n\n\n\n11-&gt;12\n\n\n\n\n\n13\n\nCsvExec: file_groups={1 group: [[lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\n\n\n\n12-&gt;13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that a physical plan has much more details than a logical plan; it contains everything needed to execute the query!\n\n\n(Optional: we often have physical optimizers that optimize on a physical plan. Omitted here for simplicity)"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-6-query-execution",
    "href": "posts/sql-to-results/index.html#section-6-query-execution",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 6: Query Execution",
    "text": "Section 6: Query Execution\n\nInput\nA physical plan\n\n\nOutput\nThe final output is like this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\n\n\nHow to execute a physical plan?\nThe simplest execution model is pull-based execution, which implements a post-order traversal of the physical plan. For a tree (like blow), we get a traversal order of D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A: \nApplying our physical graph above, we get an execution order of:\n\nCsvExec (orders.csv)\nRepartitionExec\nFilterExec\nCoalesceBatchesExec\nRepartitionExec\nCoalesceBatchesExec\nCsvExec (lineitem.csv)\nRepartitionExec\nRepartitionExec\nCoalesceBatchesExec\nHashJoinExec\nCoalesceBatchesExec\nProjectionExec\n\nThe RepartitionExec and CoalesceBatchesExec are executors that partition the data for multi-thread processing (based on the Volcano execution style).\nA simplified, single-threaded, no-partitioned execution order would be:\n\n\n\n\n\ngraph LR;\n    e1[\"CsvExec (orders.csv)\"] --&gt; FilterExec\n    FilterExec --&gt; e2 \n    e2[\"CsvExec (lineitem.csv)\"] --&gt; HashJoinExec\n    HashJoinExec --&gt; ProjectionExec"
  }
]