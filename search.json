[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Database/storage systems",
    "section": "",
    "text": "What happens when you type a SQL in the database\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/sql-to-results/index.html",
    "href": "posts/sql-to-results/index.html",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "This is a working-in-progress blog post to explain how database query engine works. This is a blog post I hoped I knew when I was younger. I believe there are many textbook that covers this topic in much more details, this post aims to be a high level overview of how things work. I try to be as concrete as possible, as much examples as possible.\nFor simplification, we only consider analytical databases. We assume the data can be loaded with just one command (magic)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "href": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 1: End-To-End View",
    "text": "Section 1: End-To-End View\n\nInputs\nLet’s say we have this simple query (adapted from TPC-H query 5):\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\nWe have the following two tables (adapted from TPC-H spec).\n\nlineitem table\n\n\n\n\n\n\n\n\n\n\n\nl_orderkey\nl_linenumber\nl_shipdate\nl_commitdate\nl_receiptdate\nl_shipmode\nl_comment\n\n\n\n\n1\n1\n1994-06-01\n1994-05-15\n1994-06-15\nAIR\nDelivered on time\n\n\n\n\norders table\n\n\no_orderkey\no_orderdate\no_orderpriority\no_clerk\no_comment\n\n\n\n\n1\n1994-05-01\nurgent\nClerk#1\nNote1\n\n\n2\n1994-07-01\nlow\nClerk#2\nNote2\n\n\n\nThe lineitem table contains a order line, while the order table contains the order information. The query tries to find the order key, ship date and order date for orders that are placed in 1994.\n\n\nOutputs\nThe query is fairly simple, it joins two tables on the order key, then filters the results based on order date. If everything goes well, we should get results similar to this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\nThe goal of this document is to explain step-by-step what happens from the inputs to outputs."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-2-parsing",
    "href": "posts/sql-to-results/index.html#section-2-parsing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 2: Parsing",
    "text": "Section 2: Parsing\nSkipped for now as it is mostly orthogonal to the data system pipelines.\n\nInput\nA SQL query text.\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\n\n\nOutput\nStructured statement from the SQL (significantly simplified for brevity):\nfrom: [\n  TableWithJoins {\n    relation: Table {\n      name: ObjectName([\n        Ident {\n          value: \"orders\",\n          quote_style: None,\n        },\n      ]),\n    },\n    joins: [\n      Join {\n        relation: Table {\n          name: ObjectName([\n            Ident {\n              value: \"lineitem\",\n              quote_style: None,\n            },\n          ]),\n        },\n        join_operator: Inner(\n          On(\n            BinaryOp {\n              left: Identifier(\n                Ident {\n                  value: \"l_orderkey\",\n                  quote_style: None,\n                },\n              ),\n              op: Eq,\n              right: Identifier(\n                Ident {\n                  value: \"o_orderkey\",\n                  quote_style: None,\n                },\n              ),\n            },\n          ),\n        ),\n      },\n    ],\n  },\n],\nselection: Some(\n  BinaryOp {\n    left: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: GtEq,\n      right: TypedString {\n        data_type: Date,\n        value: \"1994-01-01\",\n      },\n    },\n    op: And,\n    right: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: Lt,\n      right: TypedString {\n        data_type: Date,\n        value: \"1995-01-01\",\n      },\n    },\n  },\n),"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-3-query-planning",
    "href": "posts/sql-to-results/index.html#section-3-query-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 3: Query Planning",
    "text": "Section 3: Query Planning\n\nInput\nThe query statement from last step.\n\n\nOutput\nThe logical query plan, something like this:\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Filter: orders.o_orderdate &gt;= CAST(Utf8(\"1994-01-01\") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(\"1995-01-01\") AS Date32)\n    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n      TableScan: orders\n      TableScan: lineitem\nPlot it as a tree. \nLogical vs physical.\ntodo: describe why we need to distinguish physical plan and logical plan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "href": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 4: Query Optimizing",
    "text": "Section 4: Query Optimizing\n\nInput\nThe (unoptimized) logical plan from last step.\n\n\nOutput\nAn optimized logical plan.\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Inner Join: orders.o_orderkey = lineitem.l_orderkey\n    Filter: orders.o_orderdate &gt;= Date32(\"8766\") AND orders.o_orderdate &lt; Date32(\"9131\")\n      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(\"8766\"), orders.o_orderdate &lt; Date32(\"9131\")]\n    TableScan: lineitem projection=[l_orderkey, l_shipdate]\n Note the difference between unoptimized and optimized plan! The Filter has been pushed down to lower level nodes. Part of the projection has been embedded to the TableScan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-5-physical-planing",
    "href": "posts/sql-to-results/index.html#section-5-physical-planing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 5: Physical Planing",
    "text": "Section 5: Physical Planing\n\nInput\nA logical plan.\n\n\nOutput\nA physical plan. Unlike logical plans, physical plans are more concrete about what to do, here’s an example:\nPhysical plan:\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n  CoalesceBatchesExec: target_batch_size=8192\n    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n          CoalesceBatchesExec: target_batch_size=8192\n            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\nWe can also plot a physical plan to a tree graph:\n\n\n\n\n\n\n\nNote\n\n\n\nNote that a physical plan has much more details than a logical plan, it contains everything needed to execute the query!\n\n\n(Optional: we often have physical optimizer that optimize on a physical plan. Omitted here for simplicity)"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-6-query-execution",
    "href": "posts/sql-to-results/index.html#section-6-query-execution",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 6: Query Execution",
    "text": "Section 6: Query Execution\n\nInput\nA physical plan\n\n\nOutput\nThe final output like this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\n\n\nHow to execute a physical plan?\nTODO: discuss pull-based and push-based execution.\nThe simplest execution model is pull-based execution, which implements a post-order traversal of the physical plan. For a tree like this (credit):  We get a traversal order of D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A\nApplying to our physical graph above, we get a execution order of:\n\nCsvExec (orders.csv)\nRepartitionExec\nFilterExec\nCoalesceBatchesExec\nRepartitionExec\nCoalesceBatchesExec\nCsvExec (lineitem.csv)\nRepartitionExec\nRepartitionExec\nCoalesceBatchesExec\nHashJoinExec\nCoalesceBatchesExec\nProjectionExec\n\nThe RepartitionExec and CoalesceBatchesExec are executors that partitions the data for multi-thread processing (based on the Volcano execution style)\nA simplified, single-threaded, no-partitioned execution order would be:\n\nCsvExec (orders.csv)\nFilterExec\nCsvExec (lineitem.csv)\nHashJoinExec\nProjectionExec"
  }
]