[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Database/storage systems",
    "section": "",
    "text": "What happens when you type a SQL in the database\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/sql-to-results/index.html",
    "href": "posts/sql-to-results/index.html",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "This is a working-in-progress blog post to explain how database query engine works. This is a blog post I hoped I knew when I was younger. I believe there are many textbook that covers this topic in much more details, this post aims to be a high level overview of how things work. I try to be as concrete as possible, as much examples as possible.\nFor simplification, we only consider analytical databases. We assume the data can be loaded with just one command (magic)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "href": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 1: End-To-End View",
    "text": "Section 1: End-To-End View\n\nInputs\nLet’s say we have this simple query (adapted from TPC-H query 5):\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\nlineitem table in CSV format:\nl_orderkey,l_linenumber,l_shipdate,l_commitdate,l_receiptdate,l_shipmode,l_comment\n1,1,1994-06-01,1994-05-15,1994-06-15,AIR,Delivered on time\norders table in CSV format:\no_orderkey,o_orderdate,o_orderpriority,o_clerk,o_comment\n1,1994-05-01,urgent,Clerk#1,Note1\n2,1994-07-01,low,Clerk#2,Note2\n\n\nOutputs\nIf everything goes well, we should get results similar to this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\nThe goal of this document is to explain step-by-step what happens from the inputs to outputs."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-2-parsing",
    "href": "posts/sql-to-results/index.html#section-2-parsing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 2: Parsing",
    "text": "Section 2: Parsing\nSkipped for now as it is mostly orthogonal to the data system pipelines.\n\nInput\nA SQL query text.\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\n\n\nOutput\nStructured statement from the SQL:\nStatement(\n    Query(\n        Query {\n            with: None,\n            body: Select(\n                Select {\n                    projection: [\n                        UnnamedExpr(\n                            Identifier(\n                                Ident {\n                                    value: \"l_orderkey\",\n                                    quote_style: None,\n                                },\n                            ),\n                        ),\n                        UnnamedExpr(\n                            Identifier(\n                                Ident {\n                                    value: \"l_shipdate\",\n                                    quote_style: None,\n                                },\n                            ),\n                        ),\n                        UnnamedExpr(\n                            Identifier(\n                                Ident {\n                                    value: \"o_orderdate\",\n                                    quote_style: None,\n                                },\n                            ),\n                        ),\n                    ],\n                    from: [\n                        TableWithJoins {\n                            relation: Table {\n                                name: ObjectName(\n                                    [\n                                        Ident {\n                                            value: \"orders\",\n                                            quote_style: None,\n                                        },\n                                    ],\n                                ),\n                                ...\n                            },\n                            joins: [\n                                Join {\n                                    relation: Table {\n                                        name: ObjectName(\n                                            [\n                                                Ident {\n                                                    value: \"lineitem\",\n                                                    quote_style: None,\n                                                },\n                                            ],\n                                        ),\n                                        ...\n                                    },\n                                    join_operator: Inner(\n                                        On(\n                                            BinaryOp {\n                                                left: Identifier(\n                                                    Ident {\n                                                        value: \"l_orderkey\",\n                                                        quote_style: None,\n                                                    },\n                                                ),\n                                                op: Eq,\n                                                right: Identifier(\n                                                    Ident {\n                                                        value: \"o_orderkey\",\n                                                        quote_style: None,\n                                                    },\n                                                ),\n                                            },\n                                        ),\n                                    ),\n                                },\n                            ],\n                        },\n                    ],\n                    selection: Some(\n                        BinaryOp {\n                            left: BinaryOp {\n                                left: Identifier(\n                                    Ident {\n                                        value: \"o_orderdate\",\n                                        quote_style: None,\n                                    },\n                                ),\n                                op: GtEq,\n                                right: TypedString {\n                                    data_type: Date,\n                                    value: \"1994-01-01\",\n                                },\n                            },\n                            op: And,\n                            right: BinaryOp {\n                                left: Identifier(\n                                    Ident {\n                                        value: \"o_orderdate\",\n                                        quote_style: None,\n                                    },\n                                ),\n                                op: Lt,\n                                right: TypedString {\n                                    data_type: Date,\n                                    value: \"1995-01-01\",\n                                },\n                            },\n                        },\n                    ),\n                    ...\n                },\n            ),\n            ...\n        },\n    ),\n)"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-3-query-planning",
    "href": "posts/sql-to-results/index.html#section-3-query-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 3: Query Planning",
    "text": "Section 3: Query Planning\n\nInput\nThe query statement from last step.\n\n\nOutput\nThe logical query plan, something like this:\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Filter: orders.o_orderdate &gt;= CAST(Utf8(\"1994-01-01\") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(\"1995-01-01\") AS Date32)\n    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n      TableScan: orders\n      TableScan: lineitem\nPlot it as a tree. \nLogical vs physical.\ntodo: describe why we need to distinguish physical plan and logical plan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-4-query-optimizing-logical-plan",
    "href": "posts/sql-to-results/index.html#section-4-query-optimizing-logical-plan",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 4: Query Optimizing (logical plan)",
    "text": "Section 4: Query Optimizing (logical plan)\n\nInput\nThe (unoptimized) logical plan from last step.\n\n\nOutput\nAn optimized logical plan.\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Inner Join: orders.o_orderkey = lineitem.l_orderkey\n    Filter: orders.o_orderdate &gt;= Date32(\"8766\") AND orders.o_orderdate &lt; Date32(\"9131\")\n      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(\"8766\"), orders.o_orderdate &lt; Date32(\"9131\")]\n    TableScan: lineitem projection=[l_orderkey, l_shipdate]\n Note the difference between unoptimized and optimized plan! The Filter has been pushed down to lower level nodes. Part of the projection has been embedded to the TableScan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-5-physical-planing",
    "href": "posts/sql-to-results/index.html#section-5-physical-planing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 5: Physical Planing",
    "text": "Section 5: Physical Planing\n\nInput\nA logical plan.\n\n\nOutput\nA physical plan. Unlike logical plans, physical plans are more concrete about what to do, here’s an example:\nPhysical plan:\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n  CoalesceBatchesExec: target_batch_size=8192\n    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n          CoalesceBatchesExec: target_batch_size=8192\n            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\nWe can also plot a physical plan to a tree graph:\n\nNote that a physical plan has much more details than a logical plan, it contains everything needed to execute the query!\n(Optional: we often have physical optimizer that optimize on a physical plan. Omitted here for simplicity)"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-6-query-execution",
    "href": "posts/sql-to-results/index.html#section-6-query-execution",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 6: Query Execution",
    "text": "Section 6: Query Execution\n\nInput\nA physical plan\n\n\nOutput\nThe final output like this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\n\n\nHow to execute a physical plan?\nTODO: discuss pull-based and push-based execution.\nThe simplest execution model is pull-based execution, which implements a post-order traversal of the physical plan. For a tree like this (credit):  We get a traversal order of D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A\nApplying to our physical graph above, we get a execution order of:\n\nCsvExec (orders.csv)\nRepartitionExec\nFilterExec\nCoalesceBatchesExec\nRepartitionExec\nCoalesceBatchesExec\nCsvExec (lineitem.csv)\nRepartitionExec\nRepartitionExec\nCoalesceBatchesExec\nHashJoinExec\nCoalesceBatchesExec\nProjectionExec\n\nThe RepartitionExec and CoalesceBatchesExec are executors that partitions the data for multi-thread processing (based on the Volcano execution style)\nA simplified, single-threaded, no-partitioned execution order would be:\n\nCsvExec (orders.csv)\nFilterExec\nCsvExec (lineitem.csv)\nHashJoinExec\nProjectionExec"
  }
]