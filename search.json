[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Database/storage systems",
    "section": "",
    "text": "Three types of good academic advisors\n\n\n\n\n\n\n\n\n\n\n\nMay 7, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWhat happens when you type a SQL in the database\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/sql-to-results/index.html",
    "href": "posts/sql-to-results/index.html",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.\nAs complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) Apache DataFusion project is a good example of building a database using well-defined industry standards like Apache Arrow, and Apache Parquet. Without home-grown solutions for storage and in-memory representation, DataFusion can be comparable or even better than alternatives like DuckDB.\nThis document aims to explain these well-defined boundaries, namely, how query engines (i.e., OLAP) transform a plain SQL query into the results we want, how every step works, and how they are connected.\n\n\n\n\n\nflowchart LR\n   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] \n   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5\n   id5[Physical plan] --&gt; |Execution| id7[Output]\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis is a blog post I hoped I knew when I was younger.\nI aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the OSTEP book (it might be too ambitious, though)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#preface",
    "href": "posts/sql-to-results/index.html#preface",
    "title": "What happens when you type a SQL in the database",
    "section": "",
    "text": "A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.\nAs complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) Apache DataFusion project is a good example of building a database using well-defined industry standards like Apache Arrow, and Apache Parquet. Without home-grown solutions for storage and in-memory representation, DataFusion can be comparable or even better than alternatives like DuckDB.\nThis document aims to explain these well-defined boundaries, namely, how query engines (i.e., OLAP) transform a plain SQL query into the results we want, how every step works, and how they are connected.\n\n\n\n\n\nflowchart LR\n   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] \n   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5\n   id5[Physical plan] --&gt; |Execution| id7[Output]\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis is a blog post I hoped I knew when I was younger.\nI aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the OSTEP book (it might be too ambitious, though)."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "href": "posts/sql-to-results/index.html#section-1-end-to-end-view",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 1: End-To-End View",
    "text": "Section 1: End-To-End View\n\nInput\n\nTable definition\nWe have the following two tables (adapted from TPC-H spec): lineitem and orders. The lineitem defines the the shipment dates, while the order defines order details.\n\n\n\n\n\nerDiagram\n  lineitem {\n      int l_orderkey\n      int l_linenumber\n      date l_shipdate\n      date l_commitdate\n      date l_receiptdate\n      string l_shipmode\n      string l_comment\n  }\n  orders {\n      int o_orderkey\n      date o_orderdate\n      string o_orderpriority\n      string o_clerk\n      string o_comment\n  }\n\n\n\n\n\n\n\n\nSQL query\nLet’s say we have this simple query (adapted from TPC-H query 5), which finds the l_orderkey, l_shipdate, and o_orderdate of orders that were placed in 1994.\nSELECT\n    l_orderkey, l_shipdate, o_orderdate\nFROM\n    orders\nJOIN\n    lineitem ON l_orderkey = o_orderkey\nWHERE\n    o_orderdate &gt;= DATE '1994-01-01'\n    AND o_orderdate &lt; DATE '1995-01-01';\n\n\n\nOutput\nThe query is pretty simple; it joins two tables on the order key and then filters the results based on the order date. If everything goes well, we should get results similar to this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-2-parsing",
    "href": "posts/sql-to-results/index.html#section-2-parsing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 2: Parsing",
    "text": "Section 2: Parsing\nI skipped it for now as it is mostly orthogonal to the data system pipelines.\n\nInput\nThe SQL query text.\n\n\nOutput\nStructured statement from the SQL (significantly simplified for brevity):\nfrom: [\n  TableWithJoins {\n    relation: Table {\n      name: ObjectName([\n        Ident {\n          value: \"orders\",\n          quote_style: None,\n        },\n      ]),\n    },\n    joins: [\n      Join {\n        relation: Table {\n          name: ObjectName([\n            Ident {\n              value: \"lineitem\",\n              quote_style: None,\n            },\n          ]),\n        },\n        join_operator: Inner(\n          On(\n            BinaryOp {\n              left: Identifier(\n                Ident {\n                  value: \"l_orderkey\",\n                  quote_style: None,\n                },\n              ),\n              op: Eq,\n              right: Identifier(\n                Ident {\n                  value: \"o_orderkey\",\n                  quote_style: None,\n                },\n              ),\n            },\n          ),\n        ),\n      },\n    ],\n  },\n],\nselection: Some(\n  BinaryOp {\n    left: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: GtEq,\n      right: TypedString {\n        data_type: Date,\n        value: \"1994-01-01\",\n      },\n    },\n    op: And,\n    right: BinaryOp {\n      left: Identifier(\n        Ident {\n          value: \"o_orderdate\",\n          quote_style: None,\n        },\n      ),\n      op: Lt,\n      right: TypedString {\n        data_type: Date,\n        value: \"1995-01-01\",\n      },\n    },\n  },\n),"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-3-query-planning",
    "href": "posts/sql-to-results/index.html#section-3-query-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 3: Query Planning",
    "text": "Section 3: Query Planning\n\nInput\nThe query statement from the last step.\n\n\nOutput\nThe logical query plan is something like this:\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Filter: orders.o_orderdate &gt;= CAST(Utf8(\"1994-01-01\") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(\"1995-01-01\") AS Date32)\n    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n      TableScan: orders\n      TableScan: lineitem\nPlot it as a tree.\n\n\n\n\n\n\n\n\n\n\n2\n\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n\n\n\n3\n\nFilter: orders.o_orderdate &gt;= CAST(Utf8(_1994-01-01_) AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(_1995-01-01_) AS Date32)\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nInner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey\n\n\n\n3-&gt;4\n\n\n\n\n\n5\n\nTableScan: orders\n\n\n\n4-&gt;5\n\n\n\n\n\n6\n\nTableScan: lineitem\n\n\n\n4-&gt;6\n\n\n\n\n\n\n\n\n\n\nLogical vs physical.\nTodo: describe why we must distinguish between physical and logical plans."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "href": "posts/sql-to-results/index.html#section-4-query-optimizing",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 4: Query Optimizing",
    "text": "Section 4: Query Optimizing\n\nInput\nThe (unoptimized) logical plan from the last step.\n\n\nOutput\nAn optimized logical plan.\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n  Inner Join: orders.o_orderkey = lineitem.l_orderkey\n    Filter: orders.o_orderdate &gt;= Date32(\"8766\") AND orders.o_orderdate &lt; Date32(\"9131\")\n      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(\"8766\"), orders.o_orderdate &lt; Date32(\"9131\")]\n    TableScan: lineitem projection=[l_orderkey, l_shipdate]\n\n\n\n\n\n\n\n\n\n\n2\n\nProjection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate\n\n\n\n3\n\nInner Join: orders.o_orderkey = lineitem.l_orderkey\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nFilter: orders.o_orderdate &gt;= Date32(_8766_) AND orders.o_orderdate &lt; Date32(_9131_)\n\n\n\n3-&gt;4\n\n\n\n\n\n6\n\nTableScan: lineitem projection=[l_orderkey, l_shipdate]\n\n\n\n3-&gt;6\n\n\n\n\n\n5\n\nTableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(_8766_), orders.o_orderdate &lt; Date32(_9131_)]\n\n\n\n4-&gt;5\n\n\n\n\n\n\n\n\n\n\nNote the difference between an unoptimized and an optimized plan! The Filter has been pushed down to lower-level nodes. Part of the projection has been embedded in the TableScan."
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-5-physical-planning",
    "href": "posts/sql-to-results/index.html#section-5-physical-planning",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 5: Physical Planning",
    "text": "Section 5: Physical Planning\n\nInput\nA logical plan.\n\n\nOutput\nA physical plan. Unlike logical plans, physical plans are more concrete about what to do; here’s an example:\nPhysical plan:\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n  CoalesceBatchesExec: target_batch_size=8192\n    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n          CoalesceBatchesExec: target_batch_size=8192\n            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n      CoalesceBatchesExec: target_batch_size=8192\n        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\nWe can also plot a physical plan to a tree graph:\n\n\n\n\n\n\n\n\n\n\n1\n\nProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]\n\n\n\n2\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n\nHashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]\n\n\n\n2-&gt;3\n\n\n\n\n\n4\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n3-&gt;4\n\n\n\n\n\n10\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n3-&gt;10\n\n\n\n\n\n5\n\nRepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8\n\n\n\n4-&gt;5\n\n\n\n\n\n6\n\nCoalesceBatchesExec: target_batch_size=8192\n\n\n\n5-&gt;6\n\n\n\n\n\n7\n\nFilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131\n\n\n\n6-&gt;7\n\n\n\n\n\n8\n\nRepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n\n\n\n7-&gt;8\n\n\n\n\n\n9\n\nCsvExec: file_groups={1 group: [[orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true\n\n\n\n8-&gt;9\n\n\n\n\n\n11\n\nRepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8\n\n\n\n10-&gt;11\n\n\n\n\n\n12\n\nRepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1\n\n\n\n11-&gt;12\n\n\n\n\n\n13\n\nCsvExec: file_groups={1 group: [[lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true\n\n\n\n12-&gt;13\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that a physical plan has much more details than a logical plan; it contains everything needed to execute the query!\n\n\n(Optional: we often have physical optimizers that optimize on a physical plan. Omitted here for simplicity)"
  },
  {
    "objectID": "posts/sql-to-results/index.html#section-6-query-execution",
    "href": "posts/sql-to-results/index.html#section-6-query-execution",
    "title": "What happens when you type a SQL in the database",
    "section": "Section 6: Query Execution",
    "text": "Section 6: Query Execution\n\nInput\nA physical plan\n\n\nOutput\nThe final output is like this:\n+------------+------------+-------------+\n| l_orderkey | l_shipdate | o_orderdate |\n+------------+------------+-------------+\n| 1          | 1994-06-01 | 1994-05-01  |\n+------------+------------+-------------+\n\n\nExecution order\nThe simplest execution model is pull-based execution, which implements a post-order traversal of the physical plan. For a tree (like blow), we get a traversal order of D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A: \nApplying our physical graph above, we get an execution order of:\n\nCsvExec (orders.csv)\nRepartitionExec\nFilterExec\nCoalesceBatchesExec\nRepartitionExec\nCoalesceBatchesExec\nCsvExec (lineitem.csv)\nRepartitionExec\nRepartitionExec\nCoalesceBatchesExec\nHashJoinExec\nCoalesceBatchesExec\nProjectionExec\n\nThe RepartitionExec and CoalesceBatchesExec are executors that partition the data for multi-thread processing (based on the Volcano execution style).\nA simplified, single-threaded, no-partitioned execution order would be:\n\n\n\n\n\ngraph LR;\n    e1[\"CsvExec (orders.csv)\"] --&gt; FilterExec\n    FilterExec --&gt; e2 \n    e2[\"CsvExec (lineitem.csv)\"] --&gt; HashJoinExec\n    HashJoinExec --&gt; ProjectionExec\n\n\n\n\n\n\n\n\nReading from disk\nCSV files are row-based, and we read them row by row, it is efficient when we frequently need to read the whole row. However, modern data analytic workloads do not always need to read the whole row; they often only need to read a subset of columns. In our example above, we only need to read l_orderkey, l_shipdate, o_orderdate, o_orderkey from the tables. If using a row-based file format (like CSV), we need to load all columns into memory, which is inefficient. Column-based file formats (like Apache Parquet) can be more efficient in this case.\nTODO: draw a figure about columnar and row storage format."
  },
  {
    "objectID": "posts/good-advisor/index.html",
    "href": "posts/good-advisor/index.html",
    "title": "Three types of good academic advisors",
    "section": "",
    "text": "Entrepreneurs, innovators, and educators.\nEntrepreneur: good at resource acquisition and allocation. Students have enough resources to reach their potential. They connect people and match the right students with the right resources. Example: Aditya Akella.\nInnovator: good at finding the right thing to do. They have a clear vision of what important problems are. They are often smart people who deeply understand the problems they work on. Students learn a lot about their methodologies, visions, and ways of thinking/reasoning. Example: Mike Stonebraker.\nEducator: good at teaching and empowering the students. They empower their student to reach their potential and to find what they are good at. They motivate their students and ignite their passions. Example: Remzi H. Arpaci-Dusseau(likely also Andrea C. Arpaci-Dusseau, but I haven’t worked with her).\nA good advisor doesn’t necessarily have to be in only one category; for example, advisors above span multiple categories, but a good advisor often has to be in at least one of the categories.\nI’m privileged enough to have worked with all three types of good advisors; however, finding a good advisor requires a lot of luck and effort. Reality check: many faculty members (especially in prestigious universities) are not in any of the categories, and most don’t even try to be a good advisor."
  },
  {
    "objectID": "posts/good-advisor/index.html#good-advisors",
    "href": "posts/good-advisor/index.html#good-advisors",
    "title": "Three types of good academic advisors",
    "section": "",
    "text": "Entrepreneurs, innovators, and educators.\nEntrepreneur: good at resource acquisition and allocation. Students have enough resources to reach their potential. They connect people and match the right students with the right resources. Example: Aditya Akella.\nInnovator: good at finding the right thing to do. They have a clear vision of what important problems are. They are often smart people who deeply understand the problems they work on. Students learn a lot about their methodologies, visions, and ways of thinking/reasoning. Example: Mike Stonebraker.\nEducator: good at teaching and empowering the students. They empower their student to reach their potential and to find what they are good at. They motivate their students and ignite their passions. Example: Remzi H. Arpaci-Dusseau(likely also Andrea C. Arpaci-Dusseau, but I haven’t worked with her).\nA good advisor doesn’t necessarily have to be in only one category; for example, advisors above span multiple categories, but a good advisor often has to be in at least one of the categories.\nI’m privileged enough to have worked with all three types of good advisors; however, finding a good advisor requires a lot of luck and effort. Reality check: many faculty members (especially in prestigious universities) are not in any of the categories, and most don’t even try to be a good advisor."
  },
  {
    "objectID": "posts/good-advisor/index.html#signs-of-bad-advisors",
    "href": "posts/good-advisor/index.html#signs-of-bad-advisors",
    "title": "Three types of good academic advisors",
    "section": "Signs of bad advisors",
    "text": "Signs of bad advisors\n\nAll happy families are alike; each unhappy family is unhappy in its own way. – Leo Tolstoy\n\nLike unhappy families, bad advisors are pretty novel in their ways of being bad; we don’t summarize them here. Instead, we list some key symptoms of working with a bad advisor.\n\nTime-to-recovery, i.e., how long does it take to recover from a meeting with your advisor?\n\nRegular meetings with your advisor can be stressful; often the time you need to prepare many slides, teach your advisor about your work, and try to get some feedback. Often, especially in the early stages of your Ph.D., you don’t have good presentation/communication skills to explain your work to your advisor. Your advisor can get impatient and think you are not progressing or working hard enough.\nThis can be frustrating and demotivating, and this pattern repeats every week. The question is, how long does it take to recover from this meeting? I have experienced that it can take a few hours, or even an entire day, to recover from the frustration and continue to work on my research. However, it does not have to be this way; a good advisor can motivate students and give concrete feedback to help them improve.\n\nBeing treated like a human, i.e., not a tool/machine to generate papers.\n\nGraduate students are first humans, then students, and then researchers, but never tools/machines to generate papers.\nMost bad advisors treat their students as leverage to fulfill their own goals. They often have very concrete expectations from their students: publish X papers in Y top-tier conferences/journals and work on Z topics with W skill sets. They evaluate their student by whether they can meet those expectations; even worse, those expectations are often inexplicit and change over time.\nIf students lag behind expectations – which happens all the time – they are often blamed for not working hard enough or not being smart enough. Worse, they will be threatened to delay graduation, withdraw funding, or even be kicked out of the program. Even if students are on track, they are often not appreciated for their hard work and dedication. They are given more work to do, and the cycle repeats.\nGraduate study is a long journey; without being treated like a real human, you feel suffering, lonely, and lost. But you deserve a supportive, fruitful, and enjoyable PhD study.\n\nBeing aware of power dynamics, you are my boss.\n\nMany people dreamed an advisor-advisee relationship would be like a marriage partnership: they respect, trust, and work together to achieve common goals.\nBut that is never the case in reality; we should stop pretending and wake up from that dream. Advisors pay their students’ salaries, and they can decide whether they can graduate or not. The conversation between an advisor and a student is never equal, and the power dynamics are always there.\nThe real challenge is whether the advisor is aware of these power dynamics and how they use them. When in disagreement, does the student have the real freedom to say no? Does the advisor sincerely feel comfortable to be challenged? Navigating these power dynamics is art for both students and advisors, but it’s on the advisors to practice and ensure students feel safe and respected."
  },
  {
    "objectID": "posts/good-advisor/index.html#self-reflections",
    "href": "posts/good-advisor/index.html#self-reflections",
    "title": "Three types of good academic advisors",
    "section": "Self-reflections",
    "text": "Self-reflections\nIt’s easy to blame bad advisors, but it is hard not to become one.\nI suffered a lot from bad advisors, but I often wonder if I can be better than them. Toxic advisors result from systematic academia problems, and changing the system is hard. That’s why good advisors are rare and worth being recognized and appreciated.\nWhen pressured with tenure, funding, and publication, will I be as nice/patient/motivating/caring as I imagined myself to be?"
  }
]