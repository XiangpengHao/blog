<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Xiangpeng&#39;s blog</title>
<link>https://blog.haoxp.xyz/</link>
<atom:link href="https://blog.haoxp.xyz/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.4.553</generator>
<lastBuildDate>Fri, 26 Apr 2024 00:00:00 GMT</lastBuildDate>
<item>
  <title>What happens when you type a SQL in the database</title>
  <link>https://blog.haoxp.xyz/posts/sql-to-results/</link>
  <description><![CDATA[ 





<section id="preface" class="level2">
<h2 class="anchored" data-anchor-id="preface">Preface</h2>
<p>A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.</p>
<p>As complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) <a href="https://github.com/apache/datafusion">Apache DataFusion</a> project is a good example of building a database using well-defined industry standards like <a href="https://arrow.apache.org">Apache Arrow</a>, and <a href="https://parquet.apache.org">Apache Parquet</a>. Without home-grown solutions for storage and in-memory representation, DataFusion is <a href="https://github.com/apache/datafusion/files/15149988/DataFusion_Query_Engine___SIGMOD_2024-FINAL-mk4.pdf">comparable or even better</a> than alternatives like <a href="https://github.com/duckdb/duckdb">DuckDB</a>.</p>
<p>Having the boundaries well-defined, this document aims to explain how query engines (i.e., <a href="https://aws.amazon.com/compare/the-difference-between-olap-and-oltp">OLAP</a>) transform a plain SQL query into the results we want, how every step works, and how they are connected.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] 
   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5
   id5[Physical plan] --&gt; |Execution| id7[Output]

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This working-in-progress blog post explains how a database query engine works. This is a blog post I hoped I knew when I was younger.</p>
<p>I aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP</a> book (might be too ambitious, though).</p>
</div>
</div>
</section>
<section id="section-1-end-to-end-view" class="level2">
<h2 class="anchored" data-anchor-id="section-1-end-to-end-view">Section 1: End-To-End View</h2>
<section id="input" class="level3">
<h3 class="anchored" data-anchor-id="input">Input</h3>
<section id="table-definition" class="level4">
<h4 class="anchored" data-anchor-id="table-definition">Table definition</h4>
<p>We have the following two tables (adapted from <a href="https://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.1.pdf">TPC-H spec</a>): <code>lineitem</code> and <code>orders</code>. The <code>lineitem</code> defines the the shipment dates, while the <code>order</code> defines order details.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">erDiagram
  lineitem {
      int l_orderkey
      int l_linenumber
      date l_shipdate
      date l_commitdate
      date l_receiptdate
      string l_shipmode
      string l_comment
  }
  orders {
      int o_orderkey
      date o_orderdate
      string o_orderpriority
      string o_clerk
      string o_comment
  }
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="sql-query" class="level4">
<h4 class="anchored" data-anchor-id="sql-query">SQL query</h4>
<p>Letâ€™s say we have this simple query (adapted from <a href="https://github.com/apache/datafusion/blob/main/benchmarks/queries/q5.sql">TPC-H query 5</a>), which finds the <code>l_orderkey</code>, <code>l_shipdate</code>, and <code>o_orderdate</code> of orders that were placed in <code>1994</code>.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">SELECT</span></span>
<span id="cb1-2">    l_orderkey, l_shipdate, o_orderdate</span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">FROM</span></span>
<span id="cb1-4">    orders</span>
<span id="cb1-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">JOIN</span></span>
<span id="cb1-6">    lineitem <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">ON</span> l_orderkey <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> o_orderkey</span>
<span id="cb1-7"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">WHERE</span></span>
<span id="cb1-8">    o_orderdate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATE</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'1994-01-01'</span></span>
<span id="cb1-9">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">AND</span> o_orderdate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATE</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'1995-01-01'</span>;</span></code></pre></div>
</section>
</section>
<section id="output" class="level3">
<h3 class="anchored" data-anchor-id="output">Output</h3>
<p>The query is pretty simple; it joins two tables on the order key and then filters the results based on the order date. If everything goes well, we should get results similar to this:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb2-1">+------------+------------+-------------+</span>
<span id="cb2-2">| l_orderkey | l_shipdate | o_orderdate |</span>
<span id="cb2-3">+------------+------------+-------------+</span>
<span id="cb2-4">| 1          | 1994-06-01 | 1994-05-01  |</span>
<span id="cb2-5">+------------+------------+-------------+</span></code></pre></div>
</section>
</section>
<section id="section-2-parsing" class="level2">
<h2 class="anchored" data-anchor-id="section-2-parsing">Section 2: Parsing</h2>
<p>I skipped it for now as it is mostly orthogonal to the data system pipelines.</p>
<section id="input-1" class="level4">
<h4 class="anchored" data-anchor-id="input-1">Input</h4>
<p>The SQL query text.</p>
</section>
<section id="output-1" class="level4">
<h4 class="anchored" data-anchor-id="output-1">Output</h4>
<p>Structured <a href="https://docs.rs/datafusion/37.1.0/datafusion/sql/parser/enum.Statement.html"><code>statement</code></a> from the SQL (significantly simplified for brevity):</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb3-1">from: [</span>
<span id="cb3-2">  TableWithJoins {</span>
<span id="cb3-3">    relation: Table {</span>
<span id="cb3-4">      name: ObjectName([</span>
<span id="cb3-5">        Ident {</span>
<span id="cb3-6">          value: "orders",</span>
<span id="cb3-7">          quote_style: None,</span>
<span id="cb3-8">        },</span>
<span id="cb3-9">      ]),</span>
<span id="cb3-10">    },</span>
<span id="cb3-11">    joins: [</span>
<span id="cb3-12">      Join {</span>
<span id="cb3-13">        relation: Table {</span>
<span id="cb3-14">          name: ObjectName([</span>
<span id="cb3-15">            Ident {</span>
<span id="cb3-16">              value: "lineitem",</span>
<span id="cb3-17">              quote_style: None,</span>
<span id="cb3-18">            },</span>
<span id="cb3-19">          ]),</span>
<span id="cb3-20">        },</span>
<span id="cb3-21">        join_operator: Inner(</span>
<span id="cb3-22">          On(</span>
<span id="cb3-23">            BinaryOp {</span>
<span id="cb3-24">              left: Identifier(</span>
<span id="cb3-25">                Ident {</span>
<span id="cb3-26">                  value: "l_orderkey",</span>
<span id="cb3-27">                  quote_style: None,</span>
<span id="cb3-28">                },</span>
<span id="cb3-29">              ),</span>
<span id="cb3-30">              op: Eq,</span>
<span id="cb3-31">              right: Identifier(</span>
<span id="cb3-32">                Ident {</span>
<span id="cb3-33">                  value: "o_orderkey",</span>
<span id="cb3-34">                  quote_style: None,</span>
<span id="cb3-35">                },</span>
<span id="cb3-36">              ),</span>
<span id="cb3-37">            },</span>
<span id="cb3-38">          ),</span>
<span id="cb3-39">        ),</span>
<span id="cb3-40">      },</span>
<span id="cb3-41">    ],</span>
<span id="cb3-42">  },</span>
<span id="cb3-43">],</span>
<span id="cb3-44">selection: Some(</span>
<span id="cb3-45">  BinaryOp {</span>
<span id="cb3-46">    left: BinaryOp {</span>
<span id="cb3-47">      left: Identifier(</span>
<span id="cb3-48">        Ident {</span>
<span id="cb3-49">          value: "o_orderdate",</span>
<span id="cb3-50">          quote_style: None,</span>
<span id="cb3-51">        },</span>
<span id="cb3-52">      ),</span>
<span id="cb3-53">      op: GtEq,</span>
<span id="cb3-54">      right: TypedString {</span>
<span id="cb3-55">        data_type: Date,</span>
<span id="cb3-56">        value: "1994-01-01",</span>
<span id="cb3-57">      },</span>
<span id="cb3-58">    },</span>
<span id="cb3-59">    op: And,</span>
<span id="cb3-60">    right: BinaryOp {</span>
<span id="cb3-61">      left: Identifier(</span>
<span id="cb3-62">        Ident {</span>
<span id="cb3-63">          value: "o_orderdate",</span>
<span id="cb3-64">          quote_style: None,</span>
<span id="cb3-65">        },</span>
<span id="cb3-66">      ),</span>
<span id="cb3-67">      op: Lt,</span>
<span id="cb3-68">      right: TypedString {</span>
<span id="cb3-69">        data_type: Date,</span>
<span id="cb3-70">        value: "1995-01-01",</span>
<span id="cb3-71">      },</span>
<span id="cb3-72">    },</span>
<span id="cb3-73">  },</span>
<span id="cb3-74">),</span></code></pre></div>
</section>
</section>
<section id="section-3-query-planning" class="level2">
<h2 class="anchored" data-anchor-id="section-3-query-planning">Section 3: Query Planning</h2>
<section id="input-2" class="level4">
<h4 class="anchored" data-anchor-id="input-2">Input</h4>
<p>The query statement from the last step.</p>
</section>
<section id="output-2" class="level4">
<h4 class="anchored" data-anchor-id="output-2">Output</h4>
<p>The logical query plan is something like this:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb4-1">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</span>
<span id="cb4-2">  Filter: orders.o_orderdate &gt;= CAST(Utf8("1994-01-01") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8("1995-01-01") AS Date32)</span>
<span id="cb4-3">    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey</span>
<span id="cb4-4">      TableScan: orders</span>
<span id="cb4-5">      TableScan: lineitem</span></code></pre></div>
<p>Plot it as a tree.</p>
<div class="cell" data-fig-height="2" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="672" height="192" viewbox="0.00 0.00 796.91 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-256 792.91,-256 792.91,4 -4,4"></polygon>
<!-- 2 -->
<g id="node1" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="603.17,-252 185.74,-252 185.74,-216 603.17,-216 603.17,-252"></polygon>
<text text-anchor="middle" x="394.46" y="-229.8" font-family="Times,serif" font-size="14.00">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</text>
</g>
<!-- 3 -->
<g id="node2" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="788.87,-180 0.04,-180 0.04,-144 788.87,-144 788.87,-180"></polygon>
<text text-anchor="middle" x="394.46" y="-157.8" font-family="Times,serif" font-size="14.00">Filter: orders.o_orderdate &gt;= CAST(Utf8(_1994-01-01_) AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(_1995-01-01_) AS Date32)</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge1" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M394.46,-205.67C394.46,-197.05 394.46,-187.79 394.46,-180.1"></path>
<polygon fill="black" stroke="black" points="390.96,-205.7 394.46,-215.7 397.96,-205.7 390.96,-205.7"></polygon>
</g>
<!-- 4 -->
<g id="node3" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="568.59,-108 220.32,-108 220.32,-72 568.59,-72 568.59,-108"></polygon>
<text text-anchor="middle" x="394.46" y="-85.8" font-family="Times,serif" font-size="14.00">Inner Join: &nbsp;Filter: lineitem.l_orderkey = orders.o_orderkey</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge2" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M394.46,-133.67C394.46,-125.05 394.46,-115.79 394.46,-108.1"></path>
<polygon fill="black" stroke="black" points="390.96,-133.7 394.46,-143.7 397.96,-133.7 390.96,-133.7"></polygon>
</g>
<!-- 5 -->
<g id="node4" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="383.42,-36 265.5,-36 265.5,0 383.42,0 383.42,-36"></polygon>
<text text-anchor="middle" x="324.46" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: orders</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge3" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M369.93,-64.48C360.56,-55.11 350.09,-44.64 341.56,-36.1"></path>
<polygon fill="black" stroke="black" points="367.61,-67.1 377.15,-71.7 372.56,-62.15 367.61,-67.1"></polygon>
</g>
<!-- 6 -->
<g id="node5" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="529.81,-36 401.11,-36 401.11,0 529.81,0 529.81,-36"></polygon>
<text text-anchor="middle" x="465.46" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: lineitem</text>
</g>
<!-- 4&#45;&gt;6 -->
<g id="edge4" class="edge">
<title>4-&gt;6</title>
<path fill="none" stroke="black" d="M419.33,-64.48C428.83,-55.11 439.45,-44.64 448.11,-36.1"></path>
<polygon fill="black" stroke="black" points="416.67,-62.18 412.01,-71.7 421.58,-67.17 416.67,-62.18"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Logical vs physical.</p>
<p>Todo: describe why we must distinguish between physical and logical plans.</p>
</section>
</section>
<section id="section-4-query-optimizing" class="level2">
<h2 class="anchored" data-anchor-id="section-4-query-optimizing">Section 4: Query Optimizing</h2>
<section id="input-3" class="level4">
<h4 class="anchored" data-anchor-id="input-3">Input</h4>
<p>The (unoptimized) logical plan from the last step.</p>
</section>
<section id="output-3" class="level4">
<h4 class="anchored" data-anchor-id="output-3">Output</h4>
<p>An optimized logical plan.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb5-1">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</span>
<span id="cb5-2">  Inner Join: orders.o_orderkey = lineitem.l_orderkey</span>
<span id="cb5-3">    Filter: orders.o_orderdate &gt;= Date32("8766") AND orders.o_orderdate &lt; Date32("9131")</span>
<span id="cb5-4">      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32("8766"), orders.o_orderdate &lt; Date32("9131")]</span>
<span id="cb5-5">    TableScan: lineitem projection=[l_orderkey, l_shipdate]</span></code></pre></div>
<div class="cell" data-fig-height="2" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="672" height="192" viewbox="0.00 0.00 1054.03 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-256 1050.03,-256 1050.03,4 -4,4"></polygon>
<!-- 2 -->
<g id="node1" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="866.24,-252 448.81,-252 448.81,-216 866.24,-216 866.24,-252"></polygon>
<text text-anchor="middle" x="657.53" y="-229.8" font-family="Times,serif" font-size="14.00">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</text>
</g>
<!-- 3 -->
<g id="node2" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="810.94,-180 504.11,-180 504.11,-144 810.94,-144 810.94,-180"></polygon>
<text text-anchor="middle" x="657.53" y="-157.8" font-family="Times,serif" font-size="14.00">Inner Join: orders.o_orderkey = lineitem.l_orderkey</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge1" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M657.53,-205.67C657.53,-197.05 657.53,-187.79 657.53,-180.1"></path>
<polygon fill="black" stroke="black" points="654.03,-205.7 657.53,-215.7 661.03,-205.7 654.03,-205.7"></polygon>
</g>
<!-- 4 -->
<g id="node3" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="696.95,-108 174.1,-108 174.1,-72 696.95,-72 696.95,-108"></polygon>
<text text-anchor="middle" x="435.53" y="-85.8" font-family="Times,serif" font-size="14.00">Filter: orders.o_orderdate &gt;= Date32(_8766_) AND orders.o_orderdate &lt; Date32(_9131_)</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge2" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M593.54,-140.83C560.7,-130.47 521.12,-117.99 489.79,-108.11"></path>
<polygon fill="black" stroke="black" points="592.91,-144.3 603.5,-143.97 595.02,-137.62 592.91,-144.3"></polygon>
</g>
<!-- 6 -->
<g id="node5" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="1046.04,-108 715.01,-108 715.01,-72 1046.04,-72 1046.04,-108"></polygon>
<text text-anchor="middle" x="880.53" y="-85.8" font-family="Times,serif" font-size="14.00">TableScan: lineitem projection=[l_orderkey, l_shipdate]</text>
</g>
<!-- 3&#45;&gt;6 -->
<g id="edge4" class="edge">
<title>3-&gt;6</title>
<path fill="none" stroke="black" d="M721.37,-140.96C754.44,-130.58 794.41,-118.03 826.02,-108.11"></path>
<polygon fill="black" stroke="black" points="720.29,-137.63 711.79,-143.97 722.38,-144.31 720.29,-137.63"></polygon>
</g>
<!-- 5 -->
<g id="node4" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="871.08,-36 -0.03,-36 -0.03,0 871.08,0 871.08,-36"></polygon>
<text text-anchor="middle" x="435.53" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(_8766_), orders.o_orderdate &lt; Date32(_9131_)]</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge3" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M435.53,-61.67C435.53,-53.05 435.53,-43.79 435.53,-36.1"></path>
<polygon fill="black" stroke="black" points="432.03,-61.7 435.53,-71.7 439.03,-61.7 432.03,-61.7"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Note the difference between an unoptimized and an optimized plan! The <code>Filter</code> has been pushed down to lower-level nodes. Part of the projection has been embedded in the <code>TableScan</code>.</p>
</section>
</section>
<section id="section-5-physical-planning" class="level2">
<h2 class="anchored" data-anchor-id="section-5-physical-planning">Section 5: Physical Planning</h2>
<section id="input-4" class="level4">
<h4 class="anchored" data-anchor-id="input-4">Input</h4>
<p>A logical plan.</p>
</section>
<section id="output-4" class="level4">
<h4 class="anchored" data-anchor-id="output-4">Output</h4>
<p>A physical plan. Unlike logical plans, physical plans are more concrete about what to do; hereâ€™s an example:</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb6-1">Physical plan:</span>
<span id="cb6-2">ProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]</span>
<span id="cb6-3">  CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-4">    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]</span>
<span id="cb6-5">      CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-6">        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8</span>
<span id="cb6-7">          CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-8">            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131</span>
<span id="cb6-9">              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</span>
<span id="cb6-10">                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true</span>
<span id="cb6-11">      CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-12">        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8</span>
<span id="cb6-13">          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</span>
<span id="cb6-14">            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true</span></code></pre></div>
<p>We can also plot a physical plan to a tree graph:</p>
<div class="cell" data-fig-height="4" data-fig-width="8" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="768" height="384" viewbox="0.00 0.00 1122.05 620.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 616)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-616 1118.05,-616 1118.05,4 -4,4"></polygon>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<polygon fill="none" stroke="black" points="895.67,-612 245.15,-612 245.15,-576 895.67,-576 895.67,-612"></polygon>
<text text-anchor="middle" x="570.41" y="-589.8" font-family="Times,serif" font-size="14.00">ProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="710.47,-540 430.34,-540 430.34,-504 710.47,-504 710.47,-540"></polygon>
<text text-anchor="middle" x="570.41" y="-517.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="black" d="M570.41,-565.67C570.41,-557.05 570.41,-547.79 570.41,-540.1"></path>
<polygon fill="black" stroke="black" points="566.91,-565.7 570.41,-575.7 573.91,-565.7 566.91,-565.7"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="1000.06,-468 140.76,-468 140.76,-432 1000.06,-432 1000.06,-468"></polygon>
<text text-anchor="middle" x="570.41" y="-445.8" font-family="Times,serif" font-size="14.00">HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M570.41,-493.67C570.41,-485.05 570.41,-475.79 570.41,-468.1"></path>
<polygon fill="black" stroke="black" points="566.91,-493.7 570.41,-503.7 573.91,-493.7 566.91,-493.7"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="561.47,-396 281.34,-396 281.34,-360 561.47,-360 561.47,-396"></polygon>
<text text-anchor="middle" x="421.41" y="-373.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M524.69,-427.52C503.19,-417.42 477.91,-405.54 457.74,-396.07"></path>
<polygon fill="black" stroke="black" points="523.42,-430.79 533.96,-431.88 526.4,-424.46 523.42,-430.79"></polygon>
</g>
<!-- 10 -->
<g id="node10" class="node">
<title>10</title>
<polygon fill="none" stroke="black" points="899.47,-396 619.34,-396 619.34,-360 899.47,-360 899.47,-396"></polygon>
<text text-anchor="middle" x="759.41" y="-373.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 3&#45;&gt;10 -->
<g id="edge9" class="edge">
<title>3-&gt;10</title>
<path fill="none" stroke="black" d="M626.21,-428.33C653.94,-418.06 687.05,-405.8 713.32,-396.07"></path>
<polygon fill="black" stroke="black" points="624.81,-425.12 616.64,-431.88 627.24,-431.68 624.81,-425.12"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="562.11,-324 118.71,-324 118.71,-288 562.11,-288 562.11,-324"></polygon>
<text text-anchor="middle" x="340.41" y="-301.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M393.68,-353.03C382.67,-343.52 370.27,-332.8 360.2,-324.1"></path>
<polygon fill="black" stroke="black" points="391.53,-355.81 401.39,-359.7 396.11,-350.51 391.53,-355.81"></polygon>
</g>
<!-- 6 -->
<g id="node6" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="467.47,-252 187.34,-252 187.34,-216 467.47,-216 467.47,-252"></polygon>
<text text-anchor="middle" x="327.41" y="-229.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 5&#45;&gt;6 -->
<g id="edge5" class="edge">
<title>5-&gt;6</title>
<path fill="none" stroke="black" d="M335.33,-277.67C333.73,-269.05 332.01,-259.79 330.59,-252.1"></path>
<polygon fill="black" stroke="black" points="331.93,-278.5 337.2,-287.7 338.81,-277.23 331.93,-278.5"></polygon>
</g>
<!-- 7 -->
<g id="node7" class="node">
<title>7</title>
<polygon fill="none" stroke="black" points="494.62,-180 108.19,-180 108.19,-144 494.62,-144 494.62,-180"></polygon>
<text text-anchor="middle" x="301.41" y="-157.8" font-family="Times,serif" font-size="14.00">FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131</text>
</g>
<!-- 6&#45;&gt;7 -->
<g id="edge6" class="edge">
<title>6-&gt;7</title>
<path fill="none" stroke="black" d="M317.47,-206.23C314.21,-197.46 310.68,-187.96 307.76,-180.1"></path>
<polygon fill="black" stroke="black" points="314.22,-207.54 320.98,-215.7 320.78,-205.1 314.22,-207.54"></polygon>
</g>
<!-- 8 -->
<g id="node8" class="node">
<title>8</title>
<polygon fill="none" stroke="black" points="510.59,-108 92.23,-108 92.23,-72 510.59,-72 510.59,-108"></polygon>
<text text-anchor="middle" x="301.41" y="-85.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</text>
</g>
<!-- 7&#45;&gt;8 -->
<g id="edge7" class="edge">
<title>7-&gt;8</title>
<path fill="none" stroke="black" d="M301.41,-133.67C301.41,-125.05 301.41,-115.79 301.41,-108.1"></path>
<polygon fill="black" stroke="black" points="297.91,-133.7 301.41,-143.7 304.91,-133.7 297.91,-133.7"></polygon>
</g>
<!-- 9 -->
<g id="node9" class="node">
<title>9</title>
<polygon fill="none" stroke="black" points="602.73,-36 0.09,-36 0.09,0 602.73,0 602.73,-36"></polygon>
<text text-anchor="middle" x="301.41" y="-13.8" font-family="Times,serif" font-size="14.00">CsvExec: file_groups={1 group: [[orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true</text>
</g>
<!-- 8&#45;&gt;9 -->
<g id="edge8" class="edge">
<title>8-&gt;9</title>
<path fill="none" stroke="black" d="M301.41,-61.67C301.41,-53.05 301.41,-43.79 301.41,-36.1"></path>
<polygon fill="black" stroke="black" points="297.91,-61.7 301.41,-71.7 304.91,-61.7 297.91,-61.7"></polygon>
</g>
<!-- 11 -->
<g id="node11" class="node">
<title>11</title>
<polygon fill="none" stroke="black" points="1026.5,-324 586.32,-324 586.32,-288 1026.5,-288 1026.5,-324"></polygon>
<text text-anchor="middle" x="806.41" y="-301.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8</text>
</g>
<!-- 10&#45;&gt;11 -->
<g id="edge10" class="edge">
<title>10-&gt;11</title>
<path fill="none" stroke="black" d="M776.62,-351.36C782.72,-342.28 789.42,-332.3 794.92,-324.1"></path>
<polygon fill="black" stroke="black" points="773.7,-349.44 771.03,-359.7 779.51,-353.35 773.7,-349.44"></polygon>
</g>
<!-- 12 -->
<g id="node12" class="node">
<title>12</title>
<polygon fill="none" stroke="black" points="1018.59,-252 600.23,-252 600.23,-216 1018.59,-216 1018.59,-252"></polygon>
<text text-anchor="middle" x="809.41" y="-229.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</text>
</g>
<!-- 11&#45;&gt;12 -->
<g id="edge11" class="edge">
<title>11-&gt;12</title>
<path fill="none" stroke="black" d="M807.58,-277.67C807.95,-269.05 808.35,-259.79 808.68,-252.1"></path>
<polygon fill="black" stroke="black" points="804.08,-277.56 807.15,-287.7 811.08,-277.86 804.08,-277.56"></polygon>
</g>
<!-- 13 -->
<g id="node13" class="node">
<title>13</title>
<polygon fill="none" stroke="black" points="1114.19,-180 512.62,-180 512.62,-144 1114.19,-144 1114.19,-180"></polygon>
<text text-anchor="middle" x="813.41" y="-157.8" font-family="Times,serif" font-size="14.00">CsvExec: file_groups={1 group: [[lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true</text>
</g>
<!-- 12&#45;&gt;13 -->
<g id="edge12" class="edge">
<title>12-&gt;13</title>
<path fill="none" stroke="black" d="M810.97,-205.67C811.46,-197.05 811.99,-187.79 812.43,-180.1"></path>
<polygon fill="black" stroke="black" points="807.47,-205.51 810.4,-215.7 814.46,-205.91 807.47,-205.51"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that a physical plan has much more details than a logical plan; it contains everything needed to execute the query!</p>
</div>
</div>
<p>(Optional: we often have physical optimizers that optimize on a physical plan. Omitted here for simplicity)</p>
</section>
</section>
<section id="section-6-query-execution" class="level2">
<h2 class="anchored" data-anchor-id="section-6-query-execution">Section 6: Query Execution</h2>
<section id="input-5" class="level4">
<h4 class="anchored" data-anchor-id="input-5">Input</h4>
<p>A physical plan</p>
</section>
<section id="output-5" class="level4">
<h4 class="anchored" data-anchor-id="output-5">Output</h4>
<p>The final output is like this:</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb7-1">+------------+------------+-------------+</span>
<span id="cb7-2">| l_orderkey | l_shipdate | o_orderdate |</span>
<span id="cb7-3">+------------+------------+-------------+</span>
<span id="cb7-4">| 1          | 1994-06-01 | 1994-05-01  |</span>
<span id="cb7-5">+------------+------------+-------------+</span></code></pre></div>
</section>
<section id="how-to-execute-a-physical-plan" class="level3">
<h3 class="anchored" data-anchor-id="how-to-execute-a-physical-plan">How to execute a physical plan?</h3>
<p>The simplest execution model is <a href="https://justinjaffray.com/query-engines-push-vs.-pull/">pull-based execution</a>, which implements a <a href="https://www.freecodecamp.org/news/binary-search-tree-traversal-inorder-preorder-post-order-for-bst/">post-order traversal</a> of the physical plan. For a tree (like blow), we get a traversal order of <code>D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A</code>: <img src="https://blog.haoxp.xyz/posts/sql-to-results/f4.png" class="img-fluid"></p>
<p>Applying our physical graph above, we get an execution order of:</p>
<ol type="1">
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/datasource/physical_plan/struct.CsvExec.html"><code>CsvExec (orders.csv)</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/filter/struct.FilterExec.html"><code>FilterExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/datasource/physical_plan/struct.CsvExec.html"><code>CsvExec (lineitem.csv)</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/joins/struct.HashJoinExec.html"><code>HashJoinExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/projection/struct.ProjectionExec.html"><code>ProjectionExec</code></a></p></li>
</ol>
<p>The <code>RepartitionExec</code> and <code>CoalesceBatchesExec</code> are executors that partition the data for multi-thread processing (based on the <a href="https://w6113.github.io/files/papers/volcanoparallelism-89.pdf">Volcano execution</a> style).</p>
<p>A simplified, single-threaded, no-partitioned execution order would be:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR;
    e1["CsvExec (orders.csv)"] --&gt; FilterExec
    FilterExec --&gt; e2 
    e2["CsvExec (lineitem.csv)"] --&gt; HashJoinExec
    HashJoinExec --&gt; ProjectionExec
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>


</section>
</section>

 ]]></description>
  <guid>https://blog.haoxp.xyz/posts/sql-to-results/</guid>
  <pubDate>Fri, 26 Apr 2024 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
