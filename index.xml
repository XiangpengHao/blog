<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Xiangpeng&#39;s blog</title>
<link>https://blog.haoxp.xyz/</link>
<atom:link href="https://blog.haoxp.xyz/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.4.554</generator>
<lastBuildDate>Tue, 07 May 2024 00:00:00 GMT</lastBuildDate>
<item>
  <title>Three types of good academic advisors</title>
  <link>https://blog.haoxp.xyz/posts/good-advisor/</link>
  <description><![CDATA[ 





<section id="good-advisors" class="level2">
<h2 class="anchored" data-anchor-id="good-advisors">Good advisors</h2>
<p>Entrepreneurs, innovators, and educators.</p>
<p><strong>Entrepreneur</strong>: good at resource acquisition and allocation. Students have enough resources to reach their potential. They connect people and match the right students with the right resources. Example: <a href="https://www.cs.utexas.edu/~akella/">Aditya Akella</a>.</p>
<p><strong>Innovator</strong>: good at finding the right thing to do. They have a clear vision of what important problems are. They are often smart people who deeply understand the problems they work on. Students learn a lot about their methodologies, visions, and ways of thinking/reasoning. Example: <a href="https://en.wikipedia.org/wiki/Michael_Stonebraker">Mike Stonebraker</a>.</p>
<p><strong>Educator</strong>: good at teaching and empowering the students. They empower their student to reach their potential and to find what they are good at. They motivate their students and ignite their passions. Example: <a href="https://pages.cs.wisc.edu/~remzi/">Remzi H. Arpaci-Dusseau</a>(likely also <a href="https://pages.cs.wisc.edu/~dusseau/">Andrea C. Arpaci-Dusseau</a>, but I haven’t worked with her).</p>
<p>A good advisor doesn’t necessarily have to be in only one category; for example, I have seen many good educators also be good innovators, but a good advisor often has to be in at least one of the categories.</p>
<p>I’m privileged enough to have worked with all three types of good advisors; however, finding a good advisor requires a lot of luck and effort. Reality check: many faculty members (especially in prestigious universities) are not in any of the categories, and most don’t even try to be a good advisor.</p>
</section>
<section id="signs-of-bad-advisors" class="level2">
<h2 class="anchored" data-anchor-id="signs-of-bad-advisors">Signs of bad advisors</h2>
<blockquote class="blockquote">
<p>All happy families are alike; each unhappy family is unhappy in its own way. – Leo Tolstoy</p>
</blockquote>
<p>Like unhappy families, bad advisors are pretty novel in their ways of being bad; we don’t summarize them here. Instead, we list some key symptoms of working with a bad advisor.</p>
<ol type="1">
<li><strong>Time-to-recovery</strong>, i.e., how long does it take to recover from a meeting with your advisor?</li>
</ol>
<p>Regular meetings with your advisor can be stressful; often the time you need to prepare many slides, teach your advisor about your work, and try to get some feedback. Often, especially in the early stages of your Ph.D., you don’t have good presentation/communication skills to explain your work to your advisor. Your advisor can get impatient and think you are not progressing or working hard enough.</p>
<p>This can be frustrating and demotivating, and this pattern repeats every week. The question is, how long does it take to recover from this meeting? I have experienced that it can take a few hours, or even an entire day, to recover from the frustration and continue to work on my research. However, it does not have to be this way; a good advisor can motivate students and give concrete feedback to help them improve.</p>
<ol start="2" type="1">
<li><strong>Being treated like a human</strong>, i.e., not a tool/machine to generate papers.</li>
</ol>
<p>Graduate students are first humans, then students, and then researchers, but never tools/machines to generate papers.</p>
<p>Most bad advisors treat their students as leverage to fulfill their own goals. They often have very concrete expectations from their students: publish X papers in Y top-tier conferences/journals and work on Z topics with W skill sets. They evaluate their student by whether they can meet those expectations; even worse, those expectations are often inexplicit and change over time.</p>
<p>If students lag behind expectations – which happens all the time – they are often blamed for not working hard enough or not being smart enough. Worse, they will be threatened to delay graduation, withdraw funding, or even be kicked out of the program. Even if students are on track, they are often not appreciated for their hard work and dedication. They are given more work to do, and the cycle repeats.</p>
<p>Graduate study is a long journey; without being treated like a real human, you <strong>feel</strong> suffering, lonely, and lost. But you deserve a supportive, fruitful, and enjoyable PhD study.</p>
<ol start="3" type="1">
<li><strong>Being aware of power dynamics</strong>, you are my boss.</li>
</ol>
<p>Many people dreamed an advisor-advisee relationship would be like a marriage partnership: they respect, trust, and work together to achieve common goals.</p>
<p>But that is never the case in reality; we should stop pretending and wake up from that dream. Advisors pay their students’ salaries, and they can decide whether they can graduate or not. The conversation between an advisor and a student is never equal, and the power dynamics are always there.</p>
<p>The real challenge is whether the advisor is aware of these power dynamics and how they use them. When in disagreement, does the student have the real freedom to say no? Does the advisor sincerely feel comfortable to be challenged? Navigating these power dynamics is art for both students and advisors, but it’s on the advisors to practice and ensure students feel safe and respected.</p>
</section>
<section id="self-reflections" class="level2">
<h2 class="anchored" data-anchor-id="self-reflections">Self-reflections</h2>
<p>It’s easy to blame bad advisors, but it is hard not to become one.</p>
<p>I suffered a lot from bad advisors, but I often wonder if I can be better than them. Toxic advisors result from systematic academia problems, and changing the system is hard. That’s why good advisors are rare and worth being recognized and appreciated.</p>
<p>When pressured with tenure, funding, and publication, will I be as nice/patient/motivating/caring as I imagined myself to be?</p>


</section>

 ]]></description>
  <guid>https://blog.haoxp.xyz/posts/good-advisor/</guid>
  <pubDate>Tue, 07 May 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>What happens when you type a SQL in the database</title>
  <link>https://blog.haoxp.xyz/posts/sql-to-results/</link>
  <description><![CDATA[ 





<section id="preface" class="level2">
<h2 class="anchored" data-anchor-id="preface">Preface</h2>
<p>A database can be complex; it involves almost all aspects (research communities) of computer science: PL (programming language), SE (software engineering), OS (operating system), networking, storage, theory; more recently, NLP (natural language processing), and ML (machine learning). The database community is centered around the people interested in making the database (the product) better instead of pure intellectual/research interests; it is, therefore, a practical and multi-disciplinary field. This makes databases awesome but also hard to learn.</p>
<p>As complex as it is, the boundaries of the building blocks within a database are clear after decades of research and real-world operations. The recent (and state-of-the-art) <a href="https://github.com/apache/datafusion">Apache DataFusion</a> project is a good example of building a database using well-defined industry standards like <a href="https://arrow.apache.org">Apache Arrow</a>, and <a href="https://parquet.apache.org">Apache Parquet</a>. Without home-grown solutions for storage and in-memory representation, DataFusion can be <a href="https://github.com/apache/datafusion/files/15149988/DataFusion_Query_Engine___SIGMOD_2024-FINAL-mk4.pdf">comparable or even better</a> than alternatives like <a href="https://github.com/duckdb/duckdb">DuckDB</a>.</p>
<p>This document aims to explain these well-defined boundaries, namely, how query engines (i.e., <a href="https://aws.amazon.com/compare/the-difference-between-olap-and-oltp">OLAP</a>) transform a plain SQL query into the results we want, how every step works, and how they are connected.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
   id1[SQL text] --&gt; |SQL parser| id2[SQL statement] 
   id2 --&gt; |Query planner| id3[Logical plan] --&gt; |Query optimizer| id4[Optimized logical plan] --&gt; |Physical planner| id5
   id5[Physical plan] --&gt; |Execution| id7[Output]

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is a blog post I hoped I knew when I was younger.</p>
<p>I aim to make multi-year efforts to edit and improve it as I learn more about databases. I sometimes dreamed that this post could evolve to be the database equivalent of the <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP</a> book (it might be too ambitious, though).</p>
</div>
</div>
</section>
<section id="section-1-end-to-end-view" class="level2">
<h2 class="anchored" data-anchor-id="section-1-end-to-end-view">Section 1: End-To-End View</h2>
<section id="input" class="level3">
<h3 class="anchored" data-anchor-id="input">Input</h3>
<section id="table-definition" class="level4">
<h4 class="anchored" data-anchor-id="table-definition">Table definition</h4>
<p>We have the following two tables (adapted from <a href="https://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.1.pdf">TPC-H spec</a>): <code>lineitem</code> and <code>orders</code>. The <code>lineitem</code> defines the the shipment dates, while the <code>order</code> defines order details.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">erDiagram
  lineitem {
      int l_orderkey
      int l_linenumber
      date l_shipdate
      date l_commitdate
      date l_receiptdate
      string l_shipmode
      string l_comment
  }
  orders {
      int o_orderkey
      date o_orderdate
      string o_orderpriority
      string o_clerk
      string o_comment
  }
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="sql-query" class="level4">
<h4 class="anchored" data-anchor-id="sql-query">SQL query</h4>
<p>Let’s say we have this simple query (adapted from <a href="https://github.com/apache/datafusion/blob/main/benchmarks/queries/q5.sql">TPC-H query 5</a>), which finds the <code>l_orderkey</code>, <code>l_shipdate</code>, and <code>o_orderdate</code> of orders that were placed in <code>1994</code>.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">SELECT</span></span>
<span id="cb1-2">    l_orderkey, l_shipdate, o_orderdate</span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">FROM</span></span>
<span id="cb1-4">    orders</span>
<span id="cb1-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">JOIN</span></span>
<span id="cb1-6">    lineitem <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">ON</span> l_orderkey <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> o_orderkey</span>
<span id="cb1-7"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">WHERE</span></span>
<span id="cb1-8">    o_orderdate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATE</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'1994-01-01'</span></span>
<span id="cb1-9">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">AND</span> o_orderdate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">DATE</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'1995-01-01'</span>;</span></code></pre></div>
</section>
</section>
<section id="output" class="level3">
<h3 class="anchored" data-anchor-id="output">Output</h3>
<p>The query is pretty simple; it joins two tables on the order key and then filters the results based on the order date. If everything goes well, we should get results similar to this:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb2-1">+------------+------------+-------------+</span>
<span id="cb2-2">| l_orderkey | l_shipdate | o_orderdate |</span>
<span id="cb2-3">+------------+------------+-------------+</span>
<span id="cb2-4">| 1          | 1994-06-01 | 1994-05-01  |</span>
<span id="cb2-5">+------------+------------+-------------+</span></code></pre></div>
</section>
</section>
<section id="section-2-parsing" class="level2">
<h2 class="anchored" data-anchor-id="section-2-parsing">Section 2: Parsing</h2>
<p>I skipped it for now as it is mostly orthogonal to the data system pipelines.</p>
<section id="input-1" class="level4">
<h4 class="anchored" data-anchor-id="input-1">Input</h4>
<p>The SQL query text.</p>
</section>
<section id="output-1" class="level4">
<h4 class="anchored" data-anchor-id="output-1">Output</h4>
<p>Structured <a href="https://docs.rs/datafusion/37.1.0/datafusion/sql/parser/enum.Statement.html"><code>statement</code></a> from the SQL (significantly simplified for brevity):</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb3-1">from: [</span>
<span id="cb3-2">  TableWithJoins {</span>
<span id="cb3-3">    relation: Table {</span>
<span id="cb3-4">      name: ObjectName([</span>
<span id="cb3-5">        Ident {</span>
<span id="cb3-6">          value: "orders",</span>
<span id="cb3-7">          quote_style: None,</span>
<span id="cb3-8">        },</span>
<span id="cb3-9">      ]),</span>
<span id="cb3-10">    },</span>
<span id="cb3-11">    joins: [</span>
<span id="cb3-12">      Join {</span>
<span id="cb3-13">        relation: Table {</span>
<span id="cb3-14">          name: ObjectName([</span>
<span id="cb3-15">            Ident {</span>
<span id="cb3-16">              value: "lineitem",</span>
<span id="cb3-17">              quote_style: None,</span>
<span id="cb3-18">            },</span>
<span id="cb3-19">          ]),</span>
<span id="cb3-20">        },</span>
<span id="cb3-21">        join_operator: Inner(</span>
<span id="cb3-22">          On(</span>
<span id="cb3-23">            BinaryOp {</span>
<span id="cb3-24">              left: Identifier(</span>
<span id="cb3-25">                Ident {</span>
<span id="cb3-26">                  value: "l_orderkey",</span>
<span id="cb3-27">                  quote_style: None,</span>
<span id="cb3-28">                },</span>
<span id="cb3-29">              ),</span>
<span id="cb3-30">              op: Eq,</span>
<span id="cb3-31">              right: Identifier(</span>
<span id="cb3-32">                Ident {</span>
<span id="cb3-33">                  value: "o_orderkey",</span>
<span id="cb3-34">                  quote_style: None,</span>
<span id="cb3-35">                },</span>
<span id="cb3-36">              ),</span>
<span id="cb3-37">            },</span>
<span id="cb3-38">          ),</span>
<span id="cb3-39">        ),</span>
<span id="cb3-40">      },</span>
<span id="cb3-41">    ],</span>
<span id="cb3-42">  },</span>
<span id="cb3-43">],</span>
<span id="cb3-44">selection: Some(</span>
<span id="cb3-45">  BinaryOp {</span>
<span id="cb3-46">    left: BinaryOp {</span>
<span id="cb3-47">      left: Identifier(</span>
<span id="cb3-48">        Ident {</span>
<span id="cb3-49">          value: "o_orderdate",</span>
<span id="cb3-50">          quote_style: None,</span>
<span id="cb3-51">        },</span>
<span id="cb3-52">      ),</span>
<span id="cb3-53">      op: GtEq,</span>
<span id="cb3-54">      right: TypedString {</span>
<span id="cb3-55">        data_type: Date,</span>
<span id="cb3-56">        value: "1994-01-01",</span>
<span id="cb3-57">      },</span>
<span id="cb3-58">    },</span>
<span id="cb3-59">    op: And,</span>
<span id="cb3-60">    right: BinaryOp {</span>
<span id="cb3-61">      left: Identifier(</span>
<span id="cb3-62">        Ident {</span>
<span id="cb3-63">          value: "o_orderdate",</span>
<span id="cb3-64">          quote_style: None,</span>
<span id="cb3-65">        },</span>
<span id="cb3-66">      ),</span>
<span id="cb3-67">      op: Lt,</span>
<span id="cb3-68">      right: TypedString {</span>
<span id="cb3-69">        data_type: Date,</span>
<span id="cb3-70">        value: "1995-01-01",</span>
<span id="cb3-71">      },</span>
<span id="cb3-72">    },</span>
<span id="cb3-73">  },</span>
<span id="cb3-74">),</span></code></pre></div>
</section>
</section>
<section id="section-3-query-planning" class="level2">
<h2 class="anchored" data-anchor-id="section-3-query-planning">Section 3: Query Planning</h2>
<section id="input-2" class="level4">
<h4 class="anchored" data-anchor-id="input-2">Input</h4>
<p>The query statement from the last step.</p>
</section>
<section id="output-2" class="level4">
<h4 class="anchored" data-anchor-id="output-2">Output</h4>
<p>The logical query plan is something like this:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb4-1">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</span>
<span id="cb4-2">  Filter: orders.o_orderdate &gt;= CAST(Utf8("1994-01-01") AS Date32) AND orders.o_orderdate &lt; CAST(Utf8("1995-01-01") AS Date32)</span>
<span id="cb4-3">    Inner Join:  Filter: lineitem.l_orderkey = orders.o_orderkey</span>
<span id="cb4-4">      TableScan: orders</span>
<span id="cb4-5">      TableScan: lineitem</span></code></pre></div>
<p>Plot it as a tree.</p>
<div class="cell" data-fig-height="2" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="672" height="192" viewbox="0.00 0.00 796.91 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-256 792.91,-256 792.91,4 -4,4"></polygon>
<!-- 2 -->
<g id="node1" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="603.17,-252 185.74,-252 185.74,-216 603.17,-216 603.17,-252"></polygon>
<text text-anchor="middle" x="394.46" y="-229.8" font-family="Times,serif" font-size="14.00">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</text>
</g>
<!-- 3 -->
<g id="node2" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="788.87,-180 0.04,-180 0.04,-144 788.87,-144 788.87,-180"></polygon>
<text text-anchor="middle" x="394.46" y="-157.8" font-family="Times,serif" font-size="14.00">Filter: orders.o_orderdate &gt;= CAST(Utf8(_1994-01-01_) AS Date32) AND orders.o_orderdate &lt; CAST(Utf8(_1995-01-01_) AS Date32)</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge1" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M394.46,-205.67C394.46,-197.05 394.46,-187.79 394.46,-180.1"></path>
<polygon fill="black" stroke="black" points="390.96,-205.7 394.46,-215.7 397.96,-205.7 390.96,-205.7"></polygon>
</g>
<!-- 4 -->
<g id="node3" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="568.59,-108 220.32,-108 220.32,-72 568.59,-72 568.59,-108"></polygon>
<text text-anchor="middle" x="394.46" y="-85.8" font-family="Times,serif" font-size="14.00">Inner Join: &nbsp;Filter: lineitem.l_orderkey = orders.o_orderkey</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge2" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M394.46,-133.67C394.46,-125.05 394.46,-115.79 394.46,-108.1"></path>
<polygon fill="black" stroke="black" points="390.96,-133.7 394.46,-143.7 397.96,-133.7 390.96,-133.7"></polygon>
</g>
<!-- 5 -->
<g id="node4" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="383.42,-36 265.5,-36 265.5,0 383.42,0 383.42,-36"></polygon>
<text text-anchor="middle" x="324.46" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: orders</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge3" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M369.93,-64.48C360.56,-55.11 350.09,-44.64 341.56,-36.1"></path>
<polygon fill="black" stroke="black" points="367.61,-67.1 377.15,-71.7 372.56,-62.15 367.61,-67.1"></polygon>
</g>
<!-- 6 -->
<g id="node5" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="529.81,-36 401.11,-36 401.11,0 529.81,0 529.81,-36"></polygon>
<text text-anchor="middle" x="465.46" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: lineitem</text>
</g>
<!-- 4&#45;&gt;6 -->
<g id="edge4" class="edge">
<title>4-&gt;6</title>
<path fill="none" stroke="black" d="M419.33,-64.48C428.83,-55.11 439.45,-44.64 448.11,-36.1"></path>
<polygon fill="black" stroke="black" points="416.67,-62.18 412.01,-71.7 421.58,-67.17 416.67,-62.18"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Logical vs physical.</p>
<p>Todo: describe why we must distinguish between physical and logical plans.</p>
</section>
</section>
<section id="section-4-query-optimizing" class="level2">
<h2 class="anchored" data-anchor-id="section-4-query-optimizing">Section 4: Query Optimizing</h2>
<section id="input-3" class="level4">
<h4 class="anchored" data-anchor-id="input-3">Input</h4>
<p>The (unoptimized) logical plan from the last step.</p>
</section>
<section id="output-3" class="level4">
<h4 class="anchored" data-anchor-id="output-3">Output</h4>
<p>An optimized logical plan.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb5-1">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</span>
<span id="cb5-2">  Inner Join: orders.o_orderkey = lineitem.l_orderkey</span>
<span id="cb5-3">    Filter: orders.o_orderdate &gt;= Date32("8766") AND orders.o_orderdate &lt; Date32("9131")</span>
<span id="cb5-4">      TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32("8766"), orders.o_orderdate &lt; Date32("9131")]</span>
<span id="cb5-5">    TableScan: lineitem projection=[l_orderkey, l_shipdate]</span></code></pre></div>
<div class="cell" data-fig-height="2" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="672" height="192" viewbox="0.00 0.00 1054.03 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-256 1050.03,-256 1050.03,4 -4,4"></polygon>
<!-- 2 -->
<g id="node1" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="866.24,-252 448.81,-252 448.81,-216 866.24,-216 866.24,-252"></polygon>
<text text-anchor="middle" x="657.53" y="-229.8" font-family="Times,serif" font-size="14.00">Projection: lineitem.l_orderkey, lineitem.l_shipdate, orders.o_orderdate</text>
</g>
<!-- 3 -->
<g id="node2" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="810.94,-180 504.11,-180 504.11,-144 810.94,-144 810.94,-180"></polygon>
<text text-anchor="middle" x="657.53" y="-157.8" font-family="Times,serif" font-size="14.00">Inner Join: orders.o_orderkey = lineitem.l_orderkey</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge1" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M657.53,-205.67C657.53,-197.05 657.53,-187.79 657.53,-180.1"></path>
<polygon fill="black" stroke="black" points="654.03,-205.7 657.53,-215.7 661.03,-205.7 654.03,-205.7"></polygon>
</g>
<!-- 4 -->
<g id="node3" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="696.95,-108 174.1,-108 174.1,-72 696.95,-72 696.95,-108"></polygon>
<text text-anchor="middle" x="435.53" y="-85.8" font-family="Times,serif" font-size="14.00">Filter: orders.o_orderdate &gt;= Date32(_8766_) AND orders.o_orderdate &lt; Date32(_9131_)</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge2" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M593.54,-140.83C560.7,-130.47 521.12,-117.99 489.79,-108.11"></path>
<polygon fill="black" stroke="black" points="592.91,-144.3 603.5,-143.97 595.02,-137.62 592.91,-144.3"></polygon>
</g>
<!-- 6 -->
<g id="node5" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="1046.04,-108 715.01,-108 715.01,-72 1046.04,-72 1046.04,-108"></polygon>
<text text-anchor="middle" x="880.53" y="-85.8" font-family="Times,serif" font-size="14.00">TableScan: lineitem projection=[l_orderkey, l_shipdate]</text>
</g>
<!-- 3&#45;&gt;6 -->
<g id="edge4" class="edge">
<title>3-&gt;6</title>
<path fill="none" stroke="black" d="M721.37,-140.96C754.44,-130.58 794.41,-118.03 826.02,-108.11"></path>
<polygon fill="black" stroke="black" points="720.29,-137.63 711.79,-143.97 722.38,-144.31 720.29,-137.63"></polygon>
</g>
<!-- 5 -->
<g id="node4" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="871.08,-36 -0.03,-36 -0.03,0 871.08,0 871.08,-36"></polygon>
<text text-anchor="middle" x="435.53" y="-13.8" font-family="Times,serif" font-size="14.00">TableScan: orders projection=[o_orderkey, o_orderdate], partial_filters=[orders.o_orderdate &gt;= Date32(_8766_), orders.o_orderdate &lt; Date32(_9131_)]</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge3" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M435.53,-61.67C435.53,-53.05 435.53,-43.79 435.53,-36.1"></path>
<polygon fill="black" stroke="black" points="432.03,-61.7 435.53,-71.7 439.03,-61.7 432.03,-61.7"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Note the difference between an unoptimized and an optimized plan! The <code>Filter</code> has been pushed down to lower-level nodes. Part of the projection has been embedded in the <code>TableScan</code>.</p>
</section>
</section>
<section id="section-5-physical-planning" class="level2">
<h2 class="anchored" data-anchor-id="section-5-physical-planning">Section 5: Physical Planning</h2>
<section id="input-4" class="level4">
<h4 class="anchored" data-anchor-id="input-4">Input</h4>
<p>A logical plan.</p>
</section>
<section id="output-4" class="level4">
<h4 class="anchored" data-anchor-id="output-4">Output</h4>
<p>A physical plan. Unlike logical plans, physical plans are more concrete about what to do; here’s an example:</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb6-1">Physical plan:</span>
<span id="cb6-2">ProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]</span>
<span id="cb6-3">  CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-4">    HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]</span>
<span id="cb6-5">      CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-6">        RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8</span>
<span id="cb6-7">          CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-8">            FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131</span>
<span id="cb6-9">              RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</span>
<span id="cb6-10">                CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true</span>
<span id="cb6-11">      CoalesceBatchesExec: target_batch_size=8192</span>
<span id="cb6-12">        RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8</span>
<span id="cb6-13">          RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</span>
<span id="cb6-14">            CsvExec: file_groups={1 group: [[Users/xiangpeng/work/coding/db-ml/bin/example-data/lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true</span></code></pre></div>
<p>We can also plot a physical plan to a tree graph:</p>
<div class="cell" data-fig-height="4" data-fig-width="8" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="768" height="384" viewbox="0.00 0.00 1122.05 620.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 616)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-616 1118.05,-616 1118.05,4 -4,4"></polygon>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<polygon fill="none" stroke="black" points="895.67,-612 245.15,-612 245.15,-576 895.67,-576 895.67,-612"></polygon>
<text text-anchor="middle" x="570.41" y="-589.8" font-family="Times,serif" font-size="14.00">ProjectionExec: expr=[l_orderkey@1 as l_orderkey, l_shipdate@2 as l_shipdate, o_orderdate@0 as o_orderdate]</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<polygon fill="none" stroke="black" points="710.47,-540 430.34,-540 430.34,-504 710.47,-504 710.47,-540"></polygon>
<text text-anchor="middle" x="570.41" y="-517.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="black" d="M570.41,-565.67C570.41,-557.05 570.41,-547.79 570.41,-540.1"></path>
<polygon fill="black" stroke="black" points="566.91,-565.7 570.41,-575.7 573.91,-565.7 566.91,-565.7"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<polygon fill="none" stroke="black" points="1000.06,-468 140.76,-468 140.76,-432 1000.06,-432 1000.06,-468"></polygon>
<text text-anchor="middle" x="570.41" y="-445.8" font-family="Times,serif" font-size="14.00">HashJoinExec: mode=Partitioned, join_type=Inner, on=[(o_orderkey@0, l_orderkey@0)], projection=[o_orderdate@1, l_orderkey@2, l_shipdate@3]</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M570.41,-493.67C570.41,-485.05 570.41,-475.79 570.41,-468.1"></path>
<polygon fill="black" stroke="black" points="566.91,-493.7 570.41,-503.7 573.91,-493.7 566.91,-493.7"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<polygon fill="none" stroke="black" points="561.47,-396 281.34,-396 281.34,-360 561.47,-360 561.47,-396"></polygon>
<text text-anchor="middle" x="421.41" y="-373.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>3-&gt;4</title>
<path fill="none" stroke="black" d="M524.69,-427.52C503.19,-417.42 477.91,-405.54 457.74,-396.07"></path>
<polygon fill="black" stroke="black" points="523.42,-430.79 533.96,-431.88 526.4,-424.46 523.42,-430.79"></polygon>
</g>
<!-- 10 -->
<g id="node10" class="node">
<title>10</title>
<polygon fill="none" stroke="black" points="899.47,-396 619.34,-396 619.34,-360 899.47,-360 899.47,-396"></polygon>
<text text-anchor="middle" x="759.41" y="-373.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 3&#45;&gt;10 -->
<g id="edge9" class="edge">
<title>3-&gt;10</title>
<path fill="none" stroke="black" d="M626.21,-428.33C653.94,-418.06 687.05,-405.8 713.32,-396.07"></path>
<polygon fill="black" stroke="black" points="624.81,-425.12 616.64,-431.88 627.24,-431.68 624.81,-425.12"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<polygon fill="none" stroke="black" points="562.11,-324 118.71,-324 118.71,-288 562.11,-288 562.11,-324"></polygon>
<text text-anchor="middle" x="340.41" y="-301.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=Hash([o_orderkey@0], 8), input_partitions=8</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M393.68,-353.03C382.67,-343.52 370.27,-332.8 360.2,-324.1"></path>
<polygon fill="black" stroke="black" points="391.53,-355.81 401.39,-359.7 396.11,-350.51 391.53,-355.81"></polygon>
</g>
<!-- 6 -->
<g id="node6" class="node">
<title>6</title>
<polygon fill="none" stroke="black" points="467.47,-252 187.34,-252 187.34,-216 467.47,-216 467.47,-252"></polygon>
<text text-anchor="middle" x="327.41" y="-229.8" font-family="Times,serif" font-size="14.00">CoalesceBatchesExec: target_batch_size=8192</text>
</g>
<!-- 5&#45;&gt;6 -->
<g id="edge5" class="edge">
<title>5-&gt;6</title>
<path fill="none" stroke="black" d="M335.33,-277.67C333.73,-269.05 332.01,-259.79 330.59,-252.1"></path>
<polygon fill="black" stroke="black" points="331.93,-278.5 337.2,-287.7 338.81,-277.23 331.93,-278.5"></polygon>
</g>
<!-- 7 -->
<g id="node7" class="node">
<title>7</title>
<polygon fill="none" stroke="black" points="494.62,-180 108.19,-180 108.19,-144 494.62,-144 494.62,-180"></polygon>
<text text-anchor="middle" x="301.41" y="-157.8" font-family="Times,serif" font-size="14.00">FilterExec: o_orderdate@1 &gt;= 8766 AND o_orderdate@1 &lt; 9131</text>
</g>
<!-- 6&#45;&gt;7 -->
<g id="edge6" class="edge">
<title>6-&gt;7</title>
<path fill="none" stroke="black" d="M317.47,-206.23C314.21,-197.46 310.68,-187.96 307.76,-180.1"></path>
<polygon fill="black" stroke="black" points="314.22,-207.54 320.98,-215.7 320.78,-205.1 314.22,-207.54"></polygon>
</g>
<!-- 8 -->
<g id="node8" class="node">
<title>8</title>
<polygon fill="none" stroke="black" points="510.59,-108 92.23,-108 92.23,-72 510.59,-72 510.59,-108"></polygon>
<text text-anchor="middle" x="301.41" y="-85.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</text>
</g>
<!-- 7&#45;&gt;8 -->
<g id="edge7" class="edge">
<title>7-&gt;8</title>
<path fill="none" stroke="black" d="M301.41,-133.67C301.41,-125.05 301.41,-115.79 301.41,-108.1"></path>
<polygon fill="black" stroke="black" points="297.91,-133.7 301.41,-143.7 304.91,-133.7 297.91,-133.7"></polygon>
</g>
<!-- 9 -->
<g id="node9" class="node">
<title>9</title>
<polygon fill="none" stroke="black" points="602.73,-36 0.09,-36 0.09,0 602.73,0 602.73,-36"></polygon>
<text text-anchor="middle" x="301.41" y="-13.8" font-family="Times,serif" font-size="14.00">CsvExec: file_groups={1 group: [[orders.csv]]}, projection=[o_orderkey, o_orderdate], has_header=true</text>
</g>
<!-- 8&#45;&gt;9 -->
<g id="edge8" class="edge">
<title>8-&gt;9</title>
<path fill="none" stroke="black" d="M301.41,-61.67C301.41,-53.05 301.41,-43.79 301.41,-36.1"></path>
<polygon fill="black" stroke="black" points="297.91,-61.7 301.41,-71.7 304.91,-61.7 297.91,-61.7"></polygon>
</g>
<!-- 11 -->
<g id="node11" class="node">
<title>11</title>
<polygon fill="none" stroke="black" points="1026.5,-324 586.32,-324 586.32,-288 1026.5,-288 1026.5,-324"></polygon>
<text text-anchor="middle" x="806.41" y="-301.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=Hash([l_orderkey@0], 8), input_partitions=8</text>
</g>
<!-- 10&#45;&gt;11 -->
<g id="edge10" class="edge">
<title>10-&gt;11</title>
<path fill="none" stroke="black" d="M776.62,-351.36C782.72,-342.28 789.42,-332.3 794.92,-324.1"></path>
<polygon fill="black" stroke="black" points="773.7,-349.44 771.03,-359.7 779.51,-353.35 773.7,-349.44"></polygon>
</g>
<!-- 12 -->
<g id="node12" class="node">
<title>12</title>
<polygon fill="none" stroke="black" points="1018.59,-252 600.23,-252 600.23,-216 1018.59,-216 1018.59,-252"></polygon>
<text text-anchor="middle" x="809.41" y="-229.8" font-family="Times,serif" font-size="14.00">RepartitionExec: partitioning=RoundRobinBatch(8), input_partitions=1</text>
</g>
<!-- 11&#45;&gt;12 -->
<g id="edge11" class="edge">
<title>11-&gt;12</title>
<path fill="none" stroke="black" d="M807.58,-277.67C807.95,-269.05 808.35,-259.79 808.68,-252.1"></path>
<polygon fill="black" stroke="black" points="804.08,-277.56 807.15,-287.7 811.08,-277.86 804.08,-277.56"></polygon>
</g>
<!-- 13 -->
<g id="node13" class="node">
<title>13</title>
<polygon fill="none" stroke="black" points="1114.19,-180 512.62,-180 512.62,-144 1114.19,-144 1114.19,-180"></polygon>
<text text-anchor="middle" x="813.41" y="-157.8" font-family="Times,serif" font-size="14.00">CsvExec: file_groups={1 group: [[lineitem.csv]]}, projection=[l_orderkey, l_shipdate], has_header=true</text>
</g>
<!-- 12&#45;&gt;13 -->
<g id="edge12" class="edge">
<title>12-&gt;13</title>
<path fill="none" stroke="black" d="M810.97,-205.67C811.46,-197.05 811.99,-187.79 812.43,-180.1"></path>
<polygon fill="black" stroke="black" points="807.47,-205.51 810.4,-215.7 814.46,-205.91 807.47,-205.51"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that a physical plan has much more details than a logical plan; it contains everything needed to execute the query!</p>
</div>
</div>
<p>(Optional: we often have physical optimizers that optimize on a physical plan. Omitted here for simplicity)</p>
</section>
</section>
<section id="section-6-query-execution" class="level2">
<h2 class="anchored" data-anchor-id="section-6-query-execution">Section 6: Query Execution</h2>
<section id="input-5" class="level4">
<h4 class="anchored" data-anchor-id="input-5">Input</h4>
<p>A physical plan</p>
</section>
<section id="output-5" class="level4">
<h4 class="anchored" data-anchor-id="output-5">Output</h4>
<p>The final output is like this:</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode txt code-with-copy"><code class="sourceCode default"><span id="cb7-1">+------------+------------+-------------+</span>
<span id="cb7-2">| l_orderkey | l_shipdate | o_orderdate |</span>
<span id="cb7-3">+------------+------------+-------------+</span>
<span id="cb7-4">| 1          | 1994-06-01 | 1994-05-01  |</span>
<span id="cb7-5">+------------+------------+-------------+</span></code></pre></div>
</section>
<section id="execution-order" class="level3">
<h3 class="anchored" data-anchor-id="execution-order">Execution order</h3>
<p>The simplest execution model is <a href="https://justinjaffray.com/query-engines-push-vs.-pull/">pull-based execution</a>, which implements a <a href="https://www.freecodecamp.org/news/binary-search-tree-traversal-inorder-preorder-post-order-for-bst/">post-order traversal</a> of the physical plan. For a tree (like blow), we get a traversal order of <code>D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A</code>: <img src="https://blog.haoxp.xyz/posts/sql-to-results/f4.png" class="img-fluid"></p>
<p>Applying our physical graph above, we get an execution order of:</p>
<ol type="1">
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/datasource/physical_plan/struct.CsvExec.html"><code>CsvExec (orders.csv)</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/filter/struct.FilterExec.html"><code>FilterExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/datasource/physical_plan/struct.CsvExec.html"><code>CsvExec (lineitem.csv)</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/repartition/struct.RepartitionExec.html"><code>RepartitionExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/joins/struct.HashJoinExec.html"><code>HashJoinExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/coalesce_batches/struct.CoalesceBatchesExec.html"><code>CoalesceBatchesExec</code></a></p></li>
<li><p><a href="https://docs.rs/datafusion/37.1.0/datafusion/physical_plan/projection/struct.ProjectionExec.html"><code>ProjectionExec</code></a></p></li>
</ol>
<p>The <code>RepartitionExec</code> and <code>CoalesceBatchesExec</code> are executors that partition the data for multi-thread processing (based on the <a href="https://w6113.github.io/files/papers/volcanoparallelism-89.pdf">Volcano execution</a> style).</p>
<p>A simplified, single-threaded, no-partitioned execution order would be:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR;
    e1["CsvExec (orders.csv)"] --&gt; FilterExec
    FilterExec --&gt; e2 
    e2["CsvExec (lineitem.csv)"] --&gt; HashJoinExec
    HashJoinExec --&gt; ProjectionExec
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="reading-from-disk" class="level3">
<h3 class="anchored" data-anchor-id="reading-from-disk">Reading from disk</h3>
<p>CSV files are row-based, and we read them row by row, it is efficient when we frequently need to read the whole row. However, modern data analytic workloads do not always need to read the whole row; they often only need to read a subset of columns. In our example above, we only need to read <code>l_orderkey</code>, <code>l_shipdate</code>, <code>o_orderdate</code>, <code>o_orderkey</code> from the tables. If using a row-based file format (like CSV), we need to load all columns into memory, which is inefficient. Column-based file formats (like <a href="https://parquet.apache.org/">Apache Parquet</a>) can be more efficient in this case.</p>
<p>TODO: draw a figure about columnar and row storage format.</p>


</section>
</section>

 ]]></description>
  <guid>https://blog.haoxp.xyz/posts/sql-to-results/</guid>
  <pubDate>Fri, 26 Apr 2024 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
